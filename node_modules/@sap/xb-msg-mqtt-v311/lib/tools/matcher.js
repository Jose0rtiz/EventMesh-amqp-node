'use strict';

const { EC, ErrMsg } = require('../errors');

// noinspection JSUnusedLocalSymbols
const SEGMENT_SEPARATOR  = '/';
// noinspection JSUnusedLocalSymbols
const WILDCARD_SEGMENT   = '+';
// noinspection JSUnusedLocalSymbols
const WILDCARD_SUBTREE   = '#';

const REGEX_ERROR_STRING = /\u0000|[\u0001-\u001F]|[\u007F-\u009F]/;
const REGEX_ERROR_TOPIC  = /\u0000|[\u0001-\u001F]|[\u007F-\u009F]|[#+]/;
const REGEX_ERROR_FILTER = /\u0000|[\u0001-\u001F]|[\u007F-\u009F]|\+(?=[^\/$])|#(?!$)|[^\/](?=#)|[^\/](?=\+)/;
const REGEX_HAS_WILDCARD = /[#+]/;

/**
 * @private
 */
class Matcher {

    static isFilterPattern(value) {
        return value.search(REGEX_HAS_WILDCARD) !== -1;
    }

    /**
     * @param {!string} value
     * @return {boolean}
     */
    static invalidString(value) {
        return (value.search(REGEX_ERROR_STRING) !== -1);
    }

    /**
     * @param {!string} topic
     * @return {boolean}
     */
    static invalidTopic(topic) {
        return (topic === '' || topic.search(REGEX_ERROR_TOPIC) !== -1);
    }

    /**
     * @param {string|Array<string>|Set<string>} filter
     * @param {Array<string>} topics
     * @param {Array<string>} patterns
     * @param {Array<Error>=} errors
     * @return {?Error}
     */
    static acceptFilter(filter, topics, patterns, errors = []) {
        let list = null;
        switch(typeof filter) {
            case 'string':
                list = [filter];
                break;
            case 'object':
                if (filter instanceof Set) {
                    list = Array.from(filter);
                    break;
                }
                if (Array.isArray(filter)) {
                    list = filter;
                    break;
                }
                errors.push(ErrMsg(EC.SUBSCRIBE_INV_FILTER_TYPE));
                break;
            default:
                errors.push(ErrMsg(EC.SUBSCRIBE_INV_FILTER_TYPE));
        }

        if (list) for (const flt of list) {
            if (flt === '') {
                errors.push(ErrMsg(EC.SUBSCRIBE_FILTER_INITIAL));
                continue;
            }
            const at = flt.search(REGEX_ERROR_FILTER);
            if (at > -1) {
                errors.push(ErrMsg(EC.SUBSCRIBE_FILTER_SYNTAX, flt.slice(0, at + 1), flt));
            } else if (flt.search(REGEX_HAS_WILDCARD) === -1) {
                topics.push(flt);
            } else {
                patterns.push(flt);
            }
        }

        switch (errors.length) {
            case 0:
                return null;
            case 1:
                return errors[0];
            default:
                // noinspection JSUnresolvedVariable
                return new Error(`${ErrMsg(EC.SUBSCRIBE_INV_FILTER).message}\n\t${errors.join('\n\t')}`);
        }
    }

    /**
     * @param {!string} filter - A valid topic filter
     * @returns {RegExp}
     */
    static filterToRegExp(filter) {

        const expr = filter
            .replace(/\$/, '\\$')             // '$' as usual character
            .replace(/^\+/, '[^/\\$]*' )      // '+' at the begin does not match '$' at begin, e.g. '$SYS'
            .replace(/\+$/g, '[^/]*$')        // '+' at the end
            .replace(/\+\//g, '[^/]*/')       // '+' and '/' behind
            .replace(/^\/#/, '\/.*' )         // '/#' only, special rule because paho and mosquitto do it this way
            .replace('/#', '.*')              // '/#' at the end
            .replace('#', '[^\\$]*')          // '#' only matches any topic that does not start with '$'
            .replace(/\//g, '\\/');           // all / (also from previous replaces) to string escape and regex escape

        return new RegExp(expr);
    }

    /**
     *
     * @param {!RegExp} expr
     * @param {!string} topic
     * @return {boolean}
     */
    static matchOnRegExp(expr, topic) {
        return topic.replace(expr, '').length === 0;
    }

}

module.exports = {
    Matcher : Matcher
};

