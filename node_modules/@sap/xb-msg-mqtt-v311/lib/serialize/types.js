'use strict';

/*********************************************************************************************************************/
/** defined types: base layer ****************************************************************************************/
/*********************************************************************************************************************/

/**
 * @typedef {Object} StreamParameters
 * @property {number} istreamHighWaterFrames - The outbound stream high water mark as number of frames.
 * @property {number} istreamHighWaterBytes - The outbound stream high water mark in bytes.
 * @property {number} ostreamHighWaterFrames - The outbound stream high water mark as number of frames.
 * @property {number} ostreamHighWaterBytes - The outbound stream high water mark in bytes.
 * @property {number} ostreamChunkRecycleLimit - A number of chunks with default size to keep in recycle buffer.
 * @property {number} ostreamChunkDefaultSize - A proposal in bytes for chunks sizes in outbound stream.
 * @property {number} ostreamPayloadCopyLimit - A proposal in bytes to avoid payload copy in outbound stream
 */

/**
 * @callback JsStyleCallback
 * @param {Error=} error
 */

/**
 * @callback NotifyOfDone
 */

/**
 * @callback NotifyOfFailed
 * @param {Error} error
 */

/**
 * @callback PacketFactory
 * @param {number} type
 * @return {!Packet}
 * @private
 */

/**
 * @callback PacketHandler
 * @param {!Packet} packet
 * @private
 */

/**
 * @typedef {number} PacketID
 * @private
 */

/**
 * @typedef {Object} PacketIdentifiable
 * @property {?PacketID} packetID
 * @private
 */

/*********************************************************************************************************************/
/** implemented types: base layer ************************************************************************************/
/*********************************************************************************************************************/

/**
 * @final
 */
class Payload {

    /**
     * @param {(string|Buffer)=} first - A string will be used as (mime) type attribute, a Buffer as first chunk
     * @param {...Buffer} chunks - Further chunks given initially
     */
    constructor(first, ...chunks) {

        /**
         * @type {Array<!Buffer>}
         */
        this.chunks = typeof first === 'string' ? chunks : Buffer.isBuffer(first) ? [first].concat(chunks) : chunks;

        /**
         * @type {?string}
         */
        this.type = typeof first === 'string' ? first : null;

        // noinspection JSUnusedGlobalSymbols
        /**
         * @type {?string}
         */
        this.encoding = null;

        // noinspection JSUnusedGlobalSymbols
        /**
         * @type {*}
         */
        this.data = null;

        // noinspection JSUnusedGlobalSymbols
        /**
         * @type {?Object}
         */
        this.properties = null;

    }

    /**
     * @return {number}
     */
    size() {
        let size = 0;
        for (const chunk of this.chunks)
            size += chunk.length;
        return size;
    }

    // noinspection JSUnusedGlobalSymbols
    /**
     * @param {number} maxSize
     * @param {function(Buffer)} consume
     */
    toSlices(maxSize, consume) {
        for (const chunk of this.chunks) {
            let offset = 0;
            let length = chunk.length;
            while (length) {
                if (length > maxSize) {
                    consume(chunk.slice(offset, offset + maxSize));
                    offset += maxSize;
                    length -= maxSize;
                } else {
                    consume(chunk.slice(offset, offset + length));
                    length = 0;
                }
            }
        }
    }

    /**
     * @param {string=} encoding
     * @returns {!string}
     */
    toString(encoding) {
        switch (this.chunks.length) {
            case 0:
                return '';
            case 1:
                return this.chunks[0].toString(encoding);
            default:
                return Buffer.concat(this.chunks).toString(encoding);
        }
    }

    /**
     * @returns {!Buffer}
     */
    toBuffer() {
        switch (this.chunks.length) {
            case 0:
                return Buffer.alloc(0);
            case 1:
                return this.chunks[0];
            default:
                return Buffer.concat(this.chunks);
        }
    }

}

/**
 * @interface
 * @private
 */
class Packet {

    /**
     * @param {number} type
     */
    constructor(type) {

        /**
         * @type {number}
         */
        this.type = type;

        /**
         * @type {number}
         */
        this.flags = 0x00;
    }

    /**
     * Update flags, calculate variable length
     * @return {number} variable length
     * @abstract
     */
    serializing() {
    }

    /**
     * @param {!Encoder} encoder
     * @abstract
     */
    serialize(encoder) {
    }

    /**
     * @param {!Decoder} decoder
     * @abstract
     */
    deserialize(decoder) {
    }

}

module.exports = {
    Payload : Payload,
    Packet : Packet,
};

