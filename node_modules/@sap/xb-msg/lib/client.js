'use strict';

const EventEmitter = require('events');
const stream = require('stream');
const Readable = stream.Readable;
const Writable = stream.Writable;

const amqp = require('@sap/xb-msg-amqp-v091');
const amqpv100 = require('@sap/xb-msg-amqp-v100');
const mqtt = require('@sap/xb-msg-mqtt-v311');

const ErrMsg = require('./errors');
const EC = ErrMsg.Codes;

/**
 * Protocols
 * @enum {string}
 */
const Protocols = {
    AMQP_V091: 'amqp-v091',
    AMQP_V100: 'amqp-v100',
    MQTT_V311: 'mqtt-v311'
};

/**
 * @final
 * @property {Array<Buffer>} chunks - A payload may consist of multiple chunks
 */
class Payload {

    /**
     * @param {...Buffer} chunks - The chunks to be added to initially
     */
    constructor(...chunks) {
        Object.defineProperty(this, 'chunks',{
            enumerable   : false,
            configurable : false,
            writable     : false,
            value        : /** @type {Array<Buffer>} */ chunks
        });
    }

    /**
     * @returns {!number}
     */
    size() {
        let size = 0;
        this.chunks.forEach((chunk) => {
            if(chunk) {
                size += chunk.length;
            }
        });
        return size;
    }

    /**
     * @param {!number} maxSize
     * @param {!function(Buffer, number)} consume
     */
    toSlices(maxSize, consume) {
        this.chunks.forEach((chunk) => {
            if(chunk) {
                let offset = 0;
                let length = chunk.length;
                while (length) {
                    if(length > maxSize) {
                        consume(chunk.slice(offset, offset + maxSize));
                        offset += maxSize;
                        length -= maxSize;
                    } else {
                        consume(chunk.slice(offset, offset + length));
                        return;
                    }
                }
            }
        });
    }

    /**
     * @param {encoding=} encoding
     * @returns {!string}
     */
    toString(encoding) {
        switch(this.chunks.length) {
            case 0:
                return '';
            case 1:
                return this.chunks[0].toString(encoding);
            default:
                return Buffer.concat(this.chunks).toString(encoding);
        }
    }

    /**
     * @returns {!Buffer}
     */
    toBuffer() {
        switch(this.chunks.length) {
            case 0:
                return Buffer.allocUnsafe(0);
            case 1:
                return this.chunks[0];
            default:
                return Buffer.concat(this.chunks);
        }
    }

}

/**
 * @callback NotifyOfFailed
 * @param {!Error} error
 */

/**
 * @callback NotifyOfDone
 */

/**
 * A stream message for unified stream processing
 * @typedef  {Object}         UnifiedStreamMessage
 * @property {string}         source      - The name of the source stream
 * @property {Buffer|Payload} payload     - The message payload, istreams provide always a Payload, ostreams accept both
 * @property {boolean}        redelivered - The message could have been delivered already, but was not acknowledged
 * @property {NotifyOfDone}   done        - A callback to use after successful message processing
 * @property {NotifyOfFailed} failed      - A callback to use on failed message processing
 */

/**
 * A readable stream for received messages in unified stream format, see also {@link UnifiedStreamMessage}
 * @class IStream
 * @extends {Readable}
 */

/**
 * The IStream has subscribed.
 * @event IStream#subscribed
 */

/**
 * A writable stream to publish messages in unified stream format, see also {@link UnifiedStreamMessage}
 * @class OStream
 * @extends {Writable}
 */

/**
 * The OStream is ready for use.
 * @event OStream#ready
 */

/**
 * A destination to be used
 * @typedef {Object}       Destination
 * @property {String}      Destination.name - A unique destination name
 * @property {Protocols}   Destination.type - Further settings depend on the protocol (see protocol-specific client libraries or examples).
 */

/**
 * @typedef {Object} Options
 * @property {Array<Destination>} destinations
 */

/**
 * A client instance can provide multiple inbound and outbound streams. Furthermore, the client behaves
 * like a facade for multiple protocol-specific clients, each one controlling an own connection.
 */
class Client extends EventEmitter {

    /**
     * The client is now connected. Application may start publishing data or subscribing topics.
     * @event Client#connected
     */

    /**
     * The client is not connected anymore.
     * @event Client#disconnected
     */

    /**
     * An error occurred.
     * @event Client#error
     * @param {!Error} error - The error object that originates from internally processing or from callbacks.
     */

    /**
     * Create a new client
     * @param {Options=} options - The options to use for a client
     * @throws {Error} - If options are invalid
     */
    constructor(options) {

        super();

        /**
         * @const {Object}
         * @private
         */
        this._options = options;

        /**
         * @const {Map<!string, !Readable>}
         * @private
         */
        this._istreams = new Map();

        /**
         * @const {Map<!string, !Writable>}
         * @private
         */
        this._ostreams = new Map();

        /**
         * @type {!number}
         * @private
         */
        this._connected = 0;

        /**
         * @type {Map<!string, !Object>}
         * @private
         */
        this._destinations = this._createDestinations(options);

    }

    /**
     * Connects all wrapped specific clients.
     *
     * @param {function()=} done
     * @param {function(!Error)=} failed
     */
    connect(done, failed) {
        if(!this._destinations){
            throw ErrMsg(EC.APP_ARGS_INVALID_OPTIONS_NO_DESTINATIONS);
        }
        this._destinations.forEach((client, name) => {
            client.connect();
        });
    }

    /**
     * Disconnects all wrapped clients.
     *
     * @final
     */
    disconnect() {
        if(!this._destinations){
            throw ErrMsg(EC.APP_ARGS_INVALID_OPTIONS_NO_DESTINATIONS);
        }
        this._destinations.forEach((client, name) => {
            client.disconnect();
        });
    }

    /**
     * Provide a unified consumer stream instance
     * @param {!string} id - The id that was declared as part of the client options
     * @returns {!IStream} A readable stream for unified stream messages
     */
    istream(id) {
        const stream = this._istreams.get(id);
        if (stream) {
            return stream;
        } else {
            throw ErrMsg(EC.APP_ARGS_INVALID_ISTREAM_ID, id);
        }
    }

    /**
     * Provide a unified producer stream instance
     * @param {!string} id - The id that was declared as part of the client options
     * @returns {!OStream} A writable stream for unified stream messages
     */
    ostream(id) {
        const stream = this._ostreams.get(id);
        if (stream) {
            return stream;
        } else {
            throw ErrMsg(EC.APP_ARGS_INVALID_OSTREAM_ID, id);
        }
    }

    /**
     *
     * @returns {Map}
     * @private
     */
    _createDestinations() {

        const destinations = new Map();

        const onConnected = () => {
            this._connected++;
            if(this._connected === this._destinations.size){
                this.emit('connected');
            }
        };

        const onError = (err) => {
            this.emit('error', err);
        };

        const onDisconnected = () => {
            this._connected--;
            if(this._connected === 0){
                this.emit('disconnected');
            }
        };

        if(!this._options.destinations){
            throw ErrMsg(EC.APP_ARGS_INVALID_OPTIONS_NO_DESTINATIONS);
        }
        for(const destination of this._options.destinations){
            let client = null;

            switch(destination.type) {
                case Protocols.AMQP_V091:
                    client = new amqp.Client(destination);
                    destinations.set(destination.name, client);
                    const channels = new Set();
                    if(destination.ostreams) {
                        Object.keys(destination.ostreams).forEach((osKey) => {
                            channels.add(destination.ostreams[osKey].channel);
                        });
                    }
                    if(destination.istreams) {
                        Object.keys(destination.istreams).forEach((isKey) => {
                            channels.add(destination.istreams[isKey].channel);
                        });
                    }
                    client.on('connected', () => {
                        channels.forEach((id) => {
                            client.channel(id).open();
                        });
                    });
                    break;
                case Protocols.MQTT_V311:
                    client = new mqtt.Client(destination);
                    destinations.set(destination.name, client);
                    break;
                default:  // Protocols.AMQP_V100:
                    client = new amqpv100.Client(destination);
                    destinations.set(destination.name, client);
            }

            client.on('connected', onConnected);
            client.on('error', onError);
            client.on('disconnected', onDisconnected);

            if(destination.ostreams) {
                const ostreamKeys = Object.keys(destination.ostreams);
                ostreamKeys.forEach((osKey) => {
                    const ostream = client.ostream(osKey);
                    if(this._ostreams.has(osKey)){
                        throw ErrMsg(EC.APP_ARGS_DUPLICATE_OSTREAM_ENTRY,osKey);
                    }
                    this._ostreams.set(osKey, ostream);
                });
            }

            if(destination.istreams) {
                const istreamKeys = Object.keys(destination.istreams);
                istreamKeys.forEach((isKey) => {
                    const istream = client.istream(isKey);
                    if(this._istreams.has(isKey)){
                        throw ErrMsg(EC.APP_ARGS_DUPLICATE_ISTREAM_ENTRY,isKey);
                    }
                    this._istreams.set(isKey, istream);
                });
            }

        }

        return destinations;

    }

}

module.exports.Protocols = Protocols;
module.exports.Payload = Payload;
module.exports.Client = Client;

