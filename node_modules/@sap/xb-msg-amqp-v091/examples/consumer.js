'use strict';

const data = { exchange: 'amq.topic', routingKey: 'a.b.*.*', noAck : false, maxCount: 100000, logCount: 10000, prefetchCount : 4000, prefetchSize : 1000000, slowWork : false };
const options = Object.assign({
    // tls : { host : '127.0.0.1', port: 5671 }
    // net : { host : '127.0.0.1', port: 5672 }
    // sasl: { user: 'guest', password: 'guest' },
}, (process.argv.length > 2) ? require(process.argv[2]) : {}); options.data = Object.assign(data, options.data);

options.istreams = {
    inputA : {channel : 1, exchange : options.data.exchange, routingKey : options.data.routingKey, exclusive : false, noAck : options.data.noAck, prefetchCount : options.data.prefetchCount, prefetchBytes : options.data.prefetchBytes}
};

const { Client } = require('../');
const { ConsumeStatistics } = require('./tools');
const stats = new ConsumeStatistics(options.data.maxCount, options.data.logCount);

const client = new Client(options);
const stream = client.istream('inputA');
const channel = client.channel(1);

stream
    .on('subscribed', () => {
        console.log('subscribed');
        if (options.data.slowWork) wait(1000, 250);
    })
    .on('data', (message) => {
        switch (stats.onReceive()) {
            case stats.COUNT:
                if (message.done) message.done();
                return;
            case stats.COUNT_LOG:
                console.log(stats.count());
                if (message.done) message.done();
                return;
            case stats.UNSUBSCRIBE:
                console.log(stats.count());
                if (message.done) message.done();
                channel.close();
                return;
            case stats.COOLDOWN:
                return;
        }
    })
;

channel
    .on('opened', () => {
        console.log('opened');
    })
    .on('error', (error) => {
        console.log(error.message);
        process.exitCode = 2;
    })
    .on('closed', (hadError) => {
        console.log('closed');
        client.disconnect();
    })
;

client
    .on('connected', (destination, brokerInfo) => {
        console.log('connected', brokerInfo.description);
        client.channel(1).open();
    })
    .on('heartbeat', () => {
        console.log('idle');
    })
    .on('error', (error) => {
        console.log(error.message);
    })
    .on('reconnecting', (destination) => {
        console.log('reconnecting, using destination ' + destination);
    })
    .on('disconnected', (hadError, byServer, statistics) => {
        console.log('disconnected');
        stats.print(statistics);
    })
;

client.connect();

// wait and work to simulate slow processing

function wait(waitTime, workTime) {
    if (stats.ready()) return;
    console.log('wait for', waitTime, 'ms');
    setTimeout(work, waitTime, waitTime, workTime);
    stream.pause();
}

function work(waitTime, workTime) {
    if (stats.ready()) return;
    console.log('work for', workTime, 'ms');
    setTimeout(wait, workTime, waitTime, workTime);
    stream.resume();
}

