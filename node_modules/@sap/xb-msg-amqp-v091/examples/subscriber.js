'use strict';

const data = { exchange: 'amq.topic', routingKey: 'a.b.*.*', noAck : true, maxCount: 100000, logCount: 10000, prefetchCount : 4000, prefetchSize : 1000000 };
const options = Object.assign({
    // tls : { host : '127.0.0.1', port: 5671 }
    // net : { host : '127.0.0.1', port: 5672 }
    // sasl: { user: 'guest', password: 'guest' },
}, (process.argv.length > 2) ? require(process.argv[2]) : {}); options.data = Object.assign(data, options.data);

const { Client } = require('../');
const { ConsumeStatistics } = require('./tools');
const stats = new ConsumeStatistics(options.data.maxCount, options.data.logCount);

const client = new Client(options);
const channel = client.channel(1);
const queue = (options.data.exchange === '') ? channel.queue(options.data.routingKey) : channel.queue(/* anonymous */);

function receive(exchange, routingKey, redelivered, properties, payload, acknowledge, reject) {
    switch (stats.onReceive()) {
        case stats.COUNT:
            if (acknowledge) acknowledge(false);
            return;
        case stats.COUNT_LOG:
            console.log(stats.count());
            if (acknowledge) acknowledge(false);
            return;
        case stats.UNSUBSCRIBE:
            console.log(stats.count());
            if (acknowledge) acknowledge(false);
            unsubscribe();
            return;
        case stats.COOLDOWN:
            if (reject) reject(true);
            return;
    }
}

function subscribe(noAck, exclusive) {
    if (options.data.prefetchCount) {
        client.channel(1).qos(options.data.prefetchBytes, options.data.prefetchCount, false);
    }
    queue.consume(false, noAck, exclusive, null, receive,
        () => {                                            // done
            console.log('subscribed');
        },
        (error) => {                                       // failed
            console.log(error.message);
            process.exitCode = 4;
        }
    );
}

function unsubscribe() {
    queue.cancel(
        () => {                                            // done
            console.log('unsubscribed');
            queue.channel.close();
        },
        (error) => {                                       // failed
            console.log(error.message);
            process.exitCode = 4;
        }
    );
}

channel
    .on('opened', () => {
        console.log('opened');
        if (queue.autoName) {                              // anonymous, transient queue
            queue.declare(false, false, true, true, null,
                (messageCount, consumerCount) => {         // done
                    queue.bind(options.data.exchange, options.data.routingKey, null,
                        () => {
                            subscribe(options.data.noAcks, true);
                        },
                        (error) => {
                            console.log(error.message);
                            process.exitCode = 3;
                        }
                    );
                },
                (error) => {                               // failed
                    console.log(error.message);
                    process.exitCode = 3;
                }
            );
        } else {                                           // existing durable queue
            subscribe(false, false);
        }
    })
    .on('error', (error) => {
        console.log(error.message);
        process.exitCode = 2;
    })
    .on('closed', (hadError) => {
        console.log('closed');
        client.disconnect();
    })
;

client
    .on('connected', (destination, brokerInfo) => {
        console.log('connected', brokerInfo.description);
        client.channel(1).open();
    })
    .on('heartbeat', () => {
        console.log('idle');
    })
    .on('error', (error) => {
        console.log(error.message);
    })
    .on('reconnecting', (destination) => {
        console.log('reconnecting, using destination ' + destination);
    })
    .on('disconnected', (hadError, byServer, statistics) => {
        console.log('disconnected');
        stats.print(statistics);
    })
;

client.connect();

