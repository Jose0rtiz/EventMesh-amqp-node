'use strict';

const data = { exchange: 'amq.topic', routingKey: 'a.b.c.d', confirms : false, mandatory: false, immediate : false, payload: Buffer.allocUnsafe(50).fill('X'), maxCount: 100000, logCount: 10000};
const options = Object.assign({
    // tls : { host : '127.0.0.1', port: 5671 }
    // net : { host : '127.0.0.1', port: 5672 }
    // sasl: { user: 'guest', password: 'guest' },
}, (process.argv.length > 2) ? require(process.argv[2]) : {}); options.data = Object.assign(data, options.data);

const { Client } = require('../');
const { ProduceStatistics } = require('./tools');
const stats = new ProduceStatistics(true, options.data.maxCount, options.data.logCount);

const client = new Client(options);
const channel = client.channel(1);

function send(exchange, routingKey, mandatory, immediate, payload) {
    stats.onSend();

    let noPause = true;
    while (noPause && stats.countMessage()) {
        noPause = exchange.publish(routingKey, mandatory, immediate, {correlationID: '1'}, payload, stats.onDone, stats.onFailed);
    }

    if (noPause) {
        stats.onStop();
    } else {
        stats.onWait();
    }
}

stats
    .on('info', (count) => {
        console.log(count);
    })
    .on('error', (error) => {
        console.log(error.message);
    })
    .on('done', () => {
        client.channel(1).close();
    })
;

channel
    .on('opened', () => {
        if (options.data.confirms) client.channel(1).confirm();
        send(channel.exchange(options.data.exchange), options.data.routingKey, options.data.mandatory, options.data.immediate, options.data.payload);
    })
    .on('return', (code, text, exchange, routingKey) => {
        console.log('message not delivered:', code, text, exchange, routingKey);
    })
    .on('error', (error) => {
        console.log(error.message);
        process.exit(2);
    })
    .on('closed', (hadError) => {
        client.disconnect();
    })
;

client
    .on('connected', (destination, brokerInfo) => {
        console.log('connected', brokerInfo.description);
        channel.open();
    })
    .on('drain', () => {
        send(channel.exchange(options.data.exchange), options.data.routingKey, options.data.mandatory, options.data.immediate, options.data.payload);
    })
    .on('error', (error) => {
        console.log(error);
    })
    .on('reconnecting', (destination) => {
        console.log('reconnecting, using destination ' + destination);
    })
    .on('disconnected', (hadError, byServer, statistics) => {
        console.log('disconnected');
        stats.print(statistics);
    })
;

client.connect();

