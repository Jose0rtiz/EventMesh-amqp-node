'use strict';

const constants = require('./constants');
const LIBRARY = constants.RUNTIME.LIBRARY;
const VERSION = constants.RUNTIME.VERSION;
const ID_RABBIT = constants.BEHAVIOR.ID.RABBIT;
const ID_QPID = constants.BEHAVIOR.ID.QPID;
const ID_DEFAULT = constants.BEHAVIOR.ID.STANDARD;
const TM_RABBIT = constants.BEHAVIOR.TYPES.RABBIT;
const TM_QPID = constants.BEHAVIOR.TYPES.QPID;
const TM_DEFAULT = constants.BEHAVIOR.TYPES.STANDARD;
const TY_INTERNAL = constants.BEHAVIOR.TYPES.INTERNAL;
const PD_RABBIT = constants.BEHAVIOR.PRODUCT.RABBIT;

/**
 * @private
 */
class PeerInfo {

    /**
     * @param {!string} product
     * @param {!string} version
     * @param {!string} platform
     * @param {!Object} capabilities
     */
    constructor(product, version, platform, capabilities) {

        /**
         * @type {!string}
         */
        this.product = product;

        /**
         * @type {!string}
         */
        this.version = version;

        /**
         * @type {!string}
         */
        this.platform = platform;

        /**
         * @type {!string}
         */
        this.description = [platform, product, version].filter(item => item).join(' ');

        /**
         * @type {!Object}
         */
        this.capabilities = capabilities;

    }

}

/**
 * @private
 */
class TypesMap {

    /**
     * @param {number} behaviorID
     */
    constructor(behaviorID) {

        /**
         * @const
         * @type {Map<number, string>}
         */
        this.int2ext = new Map();

        /**
         * @const
         * @type {Map<string, number>}
         */
        this.ext2int = new Map();

        let extTypes = null;
        switch (behaviorID) {
            case ID_RABBIT:
                extTypes = TM_RABBIT;
                break;
            case ID_QPID:
                extTypes = TM_QPID;
                break;
            default:
                extTypes = TM_DEFAULT;
                break;
        }

        for (const key of Object.keys(TY_INTERNAL)) {
            const extVal = extTypes[key];
            if (extVal) {
                const intVal = TY_INTERNAL[key];
                this.int2ext[intVal] = extVal;
                this.ext2int[extVal] = intVal;
            }
        }

        Object.freeze(this.int2ext);
        Object.freeze(this.ext2int);

    }

}

/**
 * @private
 */
class Behavior {

    /**
     * @param {!ProtocolSettings} options
     * @param {number=} behaviorID
     */
    constructor(options, behaviorID = ID_RABBIT) {

        /**
         * @type {!number}
         */
        this.maxFrameSize = options.maxBodyFrameSize;

        /**
         * @type {!number}
         */
        this.maxChannel = 0;

        /**
         * @type {!number}
         */
        this.heartbeatInterval = options.heartbeatInterval;

        /**
         * @type {?string}
         */
        this.locale = options.locale;

        /**
         * @type {!number}
         */
        this.behaviorID = behaviorID;

        /**
         * @type {Map}
         */
        this.capabilities = new Map();

        /**
         * @type {!FieldTypes}
         */
        this.fieldTypes = new TypesMap(this.behaviorID);

        /**
         * @type {?PeerInfo}
         */
        this.brokerInfo = null;

        /**
         * @const {!PeerInfo}
         */
        this.clientInfo = new PeerInfo(LIBRARY, VERSION, 'node-' + process.version, {});

    }

    /**
     * @param {!string} product
     * @param {!string} version
     * @param {!string} platform
     * @param {!Object} capabilities
     */
    updateBroker(product, version, platform, capabilities) {
        let behaviorID = null;
        switch(product) {
            case PD_RABBIT:
                behaviorID = ID_RABBIT;
                break;
            default:
                behaviorID = ID_DEFAULT;
        }

        if(behaviorID !== this.behaviorID) {
            this.behaviorID = behaviorID;
            this.fieldTypes = new TypesMap(this.behaviorID);
        }

        this.brokerInfo = new PeerInfo(product, version, platform, capabilities);
    }

    /**
     * @param {!string} locales
     * @returns {string}
     */
    selectLocale(locales) {
        this.locale = 'en_US';
        return this.locale;
    }

    connectionTimeout() {
        if(this.heartbeatInterval >= 3) {
            return Math.trunc(this.heartbeatInterval * 1000 / 3);
        } else {
            return this.heartbeatInterval * 1000;
        }
    }

}

module.exports = {
    Behavior : Behavior,
    PeerInfo : PeerInfo,
    TypesMap : TypesMap
};

