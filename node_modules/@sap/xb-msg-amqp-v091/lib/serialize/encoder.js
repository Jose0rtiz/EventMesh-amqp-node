'use strict';

const { EC, ErrMsg } = require('../errors');
const { writeUInt64BE, writeInt64BE } = require('../tools/bignum');
const { Method, MethodContent } = require('./types.js');

const constants = require('./constants');
const PROTOCOL  = constants.PROTOCOL;
const HEARTBEAT = constants.FRAME.TYPE.HEARTBEAT;
const METHOD    = constants.FRAME.TYPE.METHOD;
const HEADER    = constants.FRAME.TYPE.HEADER;
const BODY      = constants.FRAME.TYPE.BODY;
const END       = constants.FRAME.CODE.END;
const HEADSIZE  = constants.FRAME.SIZE.HEADER;
const ENDSIZE   = constants.FRAME.SIZE.END;

/*
 *   0      1         3             7                   size+7 size+8
 *   +------+---------+-------------+   +-----------+   +-----------+
 *   | type | channel |     size    |   |  payload  |   | frame-end |
 *   +------+---------+-------------+   +-----------+   +-----------+
 *    octet    short        long         size octets        octet
 */

/**
 * @callback ChunkAllocate
 * @param {number=} minSize
 * @return {!Buffer}
 */

/**
 * @callback ChunkDispatch
 * @param {!Buffer} useChunk
 * @param {?Buffer} rawChunk
 */

/**
 * @callback BlockSizer
 */

/**
 * @private
 */
class Encoder {

    /**
     * @param {!StreamParameters} options
     * @param {!Behavior} behavior
     * @param {!ChunkAllocate} allocate
     * @param {!ChunkDispatch} dispatch
     */
    constructor(options, behavior, allocate, dispatch) {

        /**
         * @type {number}
         */
        this.statChunkCount = 0;

        /**
         * @type {number}
         */
        this.statFrameCount = 0;

        /**
         * @type {number}
         */
        this.statMethodCount = 0;

        /**
         * @type {!Behavior}
         */
        this.behavior = behavior;

        /**
         * @const {number}
         * @private
         */
        this._payloadCopyLimit = options.ostreamPayloadCopyLimit;

        /**
         * @type {?Buffer}
         * @private
         */
        this._chunkWriting = null;

        /**
         * @type {number}
         * @private
         */
        this._chunkOffset = 0;

        /**
         * @type {number}
         * @private
         */
        this._chunkProduced = 0;

        /**
         * @type {number}
         * @private
         */
        this._chunkRemaining = 0;

        /**
         * @type {number}
         * @private
         */
        this._frameProduced = 0;

        /**
         * @type {!ChunkAllocate}
         * @private
         */
        this._chunkAllocate = allocate;

        /**
         * @type {!ChunkDispatch}
         * @private
         */
        this._chunkDispatch = dispatch;

        /**
         * @type {!Array<{useChunk: !Buffer, rawChunk: ?Buffer}>}
         * @private
         */
        this._queueDispatch = [];

        /**
         * @type {number}
         * @private
         */
        this._flushLocks = 0;
    }

    /**
     *
     */
    stop() {
        this.push = () => nop(false);
        this.flush = nop;
    }

    /**
     * @param {!Method} method
     * @return {boolean} - dirty
     */
    push(method) {
        this.statMethodCount += 1;
        {
            this.writeUInt8(METHOD);
            this.writeUInt16(method.channelID);
            const sizer = this.writeBlockSizeUInt32();
            this.writeUInt32(method.classMethodID);
            method.serialize(this);
            sizer();
            this.writeUInt8(END);
            this._frameProduced = 0;
            this.statFrameCount += 1;
        }

        if (method instanceof MethodContent) {
            this.writeUInt8(HEADER);
            this.writeUInt16(method.channelID);
            const sizer = this.writeBlockSizeUInt32();
            this.writeUInt16(Method.classID(method.classMethodID));
            this.writeUInt16(0);       // weight
            this.writeUInt64(method.payload.size());
            method.properties.serialize(this, method.payload);
            sizer();
            this.writeUInt8(END);
            this._frameProduced = 0;
            this.statFrameCount += 1;

            method.payload.toSlices(this.behavior.maxFrameSize - HEADSIZE - ENDSIZE, (chunk) => {
                this.writeUInt8(BODY);
                this.writeUInt16(method.channelID);
                this.writeUInt32(chunk.length);
                this._writeBlob(chunk);
                this.writeUInt8(END);
                this._frameProduced = 0;
                this.statFrameCount += 1;
            });
        }
        return true;
    }

    /**
     *
     */
    writeHeartbeat() {
        this._writing(HEADSIZE + ENDSIZE);
        this._chunkWriting.writeUInt8(HEARTBEAT, this._chunkOffset);
        this._chunkWriting.writeUInt16BE(0, this._chunkOffset + 1);
        this._chunkWriting.writeUInt32BE(0, this._chunkOffset + 3);
        this._chunkWriting.writeUInt8(END, this._chunkOffset + HEADSIZE);
    }

    /**
     *
     */
    writeProtocol() {
        this._writing(8);
        this._chunkWriting.write(PROTOCOL.NAME, this._chunkOffset, 4, 'ascii');
        this._chunkWriting.writeUInt8(PROTOCOL.ID, this._chunkOffset + 4);
        this._chunkWriting.writeUInt8(PROTOCOL.VERSION.MAJOR, this._chunkOffset + 5);
        this._chunkWriting.writeUInt8(PROTOCOL.VERSION.MINOR, this._chunkOffset + 6);
        this._chunkWriting.writeUInt8(PROTOCOL.VERSION.REVISION, this._chunkOffset + 7);
    }

    /**
     * @param {number} length
     */
    flush(length = 0) {
        if (this._chunkProduced) {
            ++this.statChunkCount;
            const useChunk = this._chunkRemaining ? this._chunkWriting.slice(0, this._chunkProduced) : this._chunkWriting;
            const rawChunk = this._chunkWriting;
            if (this._flushLocks > 0)
                this._queueDispatch.push({useChunk: useChunk, rawChunk: rawChunk});
            else
                this._chunkDispatch(useChunk, rawChunk);
        } else if (length === 0) {
            return;
        }
        this._chunkWriting = this._chunkAllocate(length);
        this._chunkProduced = 0;
        this._chunkRemaining = this._chunkWriting.length;
        this._chunkOffset = 0;
    }

    /**
     * @param {number} length
     * @private
     */
    _writing(length) {
        if (length > this._chunkRemaining) this.flush(length);
        this._chunkOffset = this._chunkProduced;
        this._chunkProduced += length;
        this._chunkRemaining -= length;
        this._frameProduced += length;
    }

    /**
     * @param {!Buffer} value
     * @private
     */
    _writeBlob(value) {
        if (value.length < this._payloadCopyLimit) {
            this._writing(value.length);
            value.copy(this._chunkWriting, this._chunkOffset);
        } else {
            this.flush();
            this._chunkDispatch(value, null);
            this._frameProduced += value.length;
        }
    }

    /**
     * @return {!BlockSizer}
     */
    writeBlockSizeUInt32() {
        this._writing(4);                          // reserve fields
        const start = this._frameProduced;         // keep data
        const chunk = this._chunkWriting;          // keep data
        const offset = this._chunkOffset;          // keep data

        this._flushLock();
        return () => {
            const size = this._frameProduced - start;
            chunk.writeUInt32BE(size, offset);
            this._flushUnlock();
        };
    }

    /**
     * @private
     */
    _flushLock() {
        ++this._flushLocks;
    }

    /**
     * @private
     */
    _flushUnlock() {
        if (this._flushLocks === 0) {
            throw ErrMsg(EC.FRAME_WRITER_BLOCK_END_NOT_EXPECTED);
        }
        if (--this._flushLocks === 0) {
            for (const item of this._queueDispatch) this._chunkDispatch(item.useChunk, item.rawChunk);
            this._queueDispatch.length = 0;
        }
    }

    /**
     * @param {number} value
     */
    writeUInt8(value) {
        this._writing(1);
        this._chunkWriting.writeUInt8(value, this._chunkOffset);
    }

    /**
     * @param {number} value
     */
    writeUInt16(value) {
        this._writing(2);
        this._chunkWriting.writeUInt16BE(value, this._chunkOffset);
    }

    /**
     * @param {number} value
     */
    writeUInt32(value) {
        this._writing(4);
        this._chunkWriting.writeUInt32BE(value, this._chunkOffset);
    }

    /**
     * @param {number} value
     */
    writeUInt64(value) {
        this._writing(8);
        writeUInt64BE(this._chunkWriting, value, this._chunkOffset);
    }

    /**
     * @param {number} value
     */
    writeInt8(value) {
        this._writing(1);
        this._chunkWriting.writeInt8(value, this._chunkOffset);
    }

    /**
     * @param {number} value
     */
    writeInt16(value) {
        this._writing(2);
        this._chunkWriting.writeInt16BE(value, this._chunkOffset);
    }

    /**
     * @param {number} value
     */
    writeInt32(value) {
        this._writing(4);
        this._chunkWriting.writeInt32BE(value, this._chunkOffset);
    }

    /**
     * @param {number} value
     */
    writeInt64(value) {
        this._writing(8);
        writeInt64BE(this._chunkWriting, value, this._chunkOffset);
    }

    /**
     * @param {number} value
     */
    writeFloat(value) {
        this._writing(4);                        // 32-bit float
        this._chunkWriting.writeFloatBE(value, this._chunkOffset);
    }

    /**
     * @param {number} value
     */
    writeDouble(value) {
        this._writing(8);                        // 64-bit double
        this._chunkWriting.writeDoubleBE(value, this._chunkOffset);
    }

    /**
     * @param {number} value
     */
    writeDecimal(value) {
        const val = Number(value);
        if (Number.isNaN(val)) {
            throw ErrMsg(EC.SERIALIZE_DECIMAL_MISMATCH, value);
        }
        const str = val.toString(10);
        const pos = str.indexOf('.');
        const dec = (pos < 0) ? 0 : str.length - 1 - pos;
        const num = (dec) ? val * Math.pow(10, dec) : val;

        this.writeUInt8(dec);
        this.writeInt32(num);
    }

    /**
     * @param {number} value
     */
    writeTimestamp(value) {
        this._writing(8);
        writeUInt64BE(this._chunkWriting, value, this._chunkOffset);
    }

    /**
     * @param {string} value
     */
    writeChar(value) {
        this._writing(1);
        this._chunkWriting.write(value, this._chunkOffset, 'utf-8');
    }

    /**
     * @param {?string} value
     */
    writeShortString(value) {
        if(value) {
            const len = Buffer.byteLength(value);
            this._writing(1 + len);
            this._chunkWriting.writeUInt8(len, this._chunkOffset);
            this._chunkWriting.write(value, this._chunkOffset + 1, len, 'utf8');
        } else {
            this._writing(1);
            this._chunkWriting.writeUInt8(0, this._chunkOffset);
        }
    }

    /**
     * @param {?string} value
     */
    writeLongString(value) {
        if(value) {
            const len = Buffer.byteLength(value);
            this._writing(4 + len);
            this._chunkWriting.writeUInt32BE(len, this._chunkOffset);
            this._chunkWriting.write(value, this._chunkOffset + 4, len, 'utf8');
        } else {
            this._writing(4);
            this._chunkWriting.writeUInt32BE(0, this._chunkOffset);
        }
    }

    /**
     * @param {...*} values
     */
    writeBitSet8Inverse(...values) {
        let bitSet = 0x00;
        let bitMask = 1;
        for (const v of values) {
            if(v) bitSet |= bitMask;
            bitMask <<= 1;
        }
        this.writeUInt8(bitSet);
    }

    /**
     * @param {...*} values
     */
    writeBitSet16(...values) {
        let bitSet = 0x0000;
        let bitMask = 1 << 15;
        for (const v of values) {
            if(v) bitSet |= bitMask;
            bitMask >>>= 1;
        }
        this.writeUInt16(bitSet);
    }

    /**
     * @param {Buffer} value
     */
    writeBytes(value) {
        if (value) {
            this.writeUInt32(value.length);
            this._writeBlob(value);
        }
    }

}

/**
 * @param {*=} result
 * @return {*}
 * @private
 */
function nop(result) { return result; }

module.exports = {
    Encoder : Encoder
};

