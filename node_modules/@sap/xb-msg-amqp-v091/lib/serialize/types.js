'use strict';

const {EC, ErrMsg} = require('../errors');
const FieldTypes = require('./constants').BEHAVIOR.TYPES.INTERNAL;

/*********************************************************************************************************************/
/** defined types: base layer ****************************************************************************************/
/*********************************************************************************************************************/

/**
 * @typedef {Object} StreamParameters
 * @property {number} istreamHighWaterFrames - The outbound stream high water mark as number of frames.
 * @property {number} istreamHighWaterBytes - The outbound stream high water mark in bytes.
 * @property {number} ostreamHighWaterFrames - The outbound stream high water mark as number of frames.
 * @property {number} ostreamHighWaterBytes - The outbound stream high water mark in bytes.
 * @property {number} ostreamChunkRecycleLimit - A number of chunks with default size to keep in recycle buffer.
 * @property {number} ostreamChunkDefaultSize - A proposal in bytes for chunks sizes in outbound stream.
 * @property {number} ostreamPayloadCopyLimit - A proposal in bytes to avoid payload copy in outbound stream
 */

/**
 * @callback NotifyOfDone
 */

/**
 * @callback NotifyOfFailed
 * @param {?Error} error
 */

/**
 * @callback NotifyOfResult
 * @param {Error=} error
 */

/**
 * @callback MethodFactory
 * @param {number} classID
 * @return {Method}
 */

/**
 * @callback MethodHandler
 * @param {Method} method
 */

/**
 * @callback HeartbeatHandler
 */

/*********************************************************************************************************************/
/** implemented types: base layer ************************************************************************************/
/*********************************************************************************************************************/

/**
 * @private
 */
class Properties {

    constructor() {
    }

    // noinspection JSUnusedGlobalSymbols
    /**
     * @return {number}
     * @abstract
     */
    classID() {
    }

    /**
     * @param {!Decoder} decoder
     * @param {!Payload} payload
     * @abstract
     */
    deserialize(decoder, payload) {
    }

    /**
     * @param {!Encoder} encoder
     * @param {!Payload} payload
     * @abstract
     */
    serialize(encoder, payload) {
    }

}

/**
 * @private
 */
class Method {

    /**
     * @param {!number} classMethodID
     * @returns {!number}
     */
    static classID(classMethodID) {
        return (classMethodID >> 16);
    }

    /**
     * @param {!number} classMethodID
     * @return {!number}
     */
    static methodID(classMethodID) {
        return (classMethodID & 0x0000FFFF);
    }

    /**
     * @param {!number} classMethodID
     * @returns {!string}
     */
    static describeID(classMethodID) {
        return ('class ' + Method.classID(classMethodID) + ' method ' + Method.methodID(classMethodID));
    }

    /**
     * @param {!number} classMethodID
     * @param {number=} requestClassMethodID
     */
    constructor(classMethodID, requestClassMethodID) {

        /**
         * @type {number}
         */
        this.classMethodID = classMethodID;

        /**
         * @type {number|undefined}
         */
        this.requestClassMethodID = requestClassMethodID ? requestClassMethodID : undefined;

        /**
         * @type {!number}
         */
        this.channelID = 0;

    }

    // noinspection JSMethodCanBeStatic
    /**
     * @return {?string}
     */
    objectKey() {
        return null;
    }

    /**
     * @param {!Decoder} decoder
     * @abstract
     */
    deserialize(decoder) {
    }

    /**
     * @param {!Encoder} encoder
     * @abstract
     */
    serialize(encoder) {
    }

}

/**
 * @abstract
 * @private
 */
class MethodContent extends Method {

    /**
     * @param {!number} classMethodID
     * @param {number=} requestClassMethodID
     */
    constructor(classMethodID, requestClassMethodID) {
        super(classMethodID, requestClassMethodID);

        /**
         * @type {Properties}
         */
        this.properties = null;

        /**
         * @type {Payload}
         */
        this.payload = null;
    }

}

/**
 * @private
 */
class MethodFactory {

    /**
     *
     */
    constructor() {
    }

    /**
     * @param {!number} classMethodID
     * @return {Method}
     * @abstract
     */
    createMethod(classMethodID) {
    }

}

/**
 * @final
 */
class Payload {

    /**
     * @param {(string|Buffer)=} first - A string will be used as (mime) type attribute, a Buffer as first chunk
     * @param {...Buffer} chunks - Further chunks given initially
     */
    constructor(first, ...chunks) {

        /**
         * @type {Array<!Buffer>}
         */
        this.chunks = typeof first === 'string' ? chunks : Buffer.isBuffer(first) ? [first].concat(chunks) : chunks;

        /**
         * @type {?string}
         */
        this.type = typeof first === 'string' ? first : null;

        /**
         * @type {?string}
         */
        this.encoding = null;

        /**
         * @type {*}
         */
        this.data = null;

        /**
         * @type {?Object}
         */
        this.properties = null;

    }

    /**
     * @return {boolean}
     */
    valid() {
        return Array.isArray(this.chunks) && this.chunks.every(item => Buffer.isBuffer(item));
    }

    /**
     * @return {number}
     */
    size() {
        let size = 0;
        for (const chunk of this.chunks)
            size += chunk.length;
        return size;
    }

    // noinspection JSUnusedGlobalSymbols
    /**
     * @param {number} maxSize
     * @param {function(Buffer)} consume
     */
    toSlices(maxSize, consume) {
        for (const chunk of this.chunks) {
            let offset = 0;
            let length = chunk.length;
            while (length) {
                if (length > maxSize) {
                    consume(chunk.slice(offset, offset + maxSize));
                    offset += maxSize;
                    length -= maxSize;
                } else {
                    consume(chunk.slice(offset, offset + length));
                    length = 0;
                }
            }
        }
    }

    /**
     * @param {string=} encoding
     * @returns {!string}
     */
    toString(encoding) {
        switch (this.chunks.length) {
            case 0:
                return '';
            case 1:
                return this.chunks[0].toString(encoding);
            default:
                return Buffer.concat(this.chunks).toString(encoding);
        }
    }

    /**
     * @returns {!Buffer}
     */
    toBuffer() {
        switch (this.chunks.length) {
            case 0:
                return Buffer.alloc(0);
            case 1:
                return this.chunks[0];
            default:
                return Buffer.concat(this.chunks);
        }
    }

}

/*********************************************************************************************************************/
/** implemented types: field values **********************************************************************************/
/*********************************************************************************************************************/

/**
 * @return {!boolean}
 * @private
 */
function isUInt64RangeValid(value) {
    return (value >= 0 && value <= Number.MAX_SAFE_INTEGER);
}

/**
 * @return {!boolean}
 * @private
 */
function isInt64RangeValid(value) {
    return (value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER);
}

/**
 * @return {!boolean}
 * @private
 */
function isUInt64(value) {
    if (isNaN(parseFloat(value)) || !isFinite(value) || value < 0)
        return false;
    if (value.length < 20)
        return true;
    return (value.length === 20 && value < '18446744073709551616');
}

/**
 * @return {!boolean}
 * @private
 */
function isInt64(value) {
    if (isNaN(parseFloat(value)) && !isFinite(value))
        return false;
    if (value.length < 19)
        return true;
    if (value.length === 19 && value < '9223372036854775808')
        return true;
    return (value.length === 20 && value.startsWith('-') && value.substr(1) < '9223372036854775808');
}

/**
 * @private
 */
class FieldLike {

    constructor() {
    }

    /**
     * @param {!Decoder} decoder
     */
    deserialize(decoder) {
    }

    /**
     * @param {!Encoder} encoder
     */
    serialize(encoder) {
    }

}

/**
 * @final
 */
class FieldValue extends FieldLike {

    /**
     *
     */
    constructor() {
        super();

        /**
         * @private
         * @type {!number}
         */
        this._type = FieldTypes.VOID;

        /**
         * @private
         * @type {!(null|boolean|number|string|FieldArray|FieldTable|Buffer)}
         */
        this._value = null;
    }

    /**
     * @param {null|boolean|number|string|FieldArray|FieldTable|Buffer} value
     * @param {number=} type
     */
    setValue(value, type) {

        switch (typeof value) {
            case 'undefined':
                this._type = FieldTypes.VOID;
                this._value = null;
                break;
            case 'boolean':
                switch (type) {
                    case FieldTypes.BOOLEAN:
                        this._value = value;
                        break;
                    case undefined:
                        throw ErrMsg(EC.SERIALIZE_TYPE_UNDEFINED);
                    default:
                        throw ErrMsg(EC.SERIALIZE_TYPE_MISMATCH);
                }
                this._type = type;
                break;
            case 'number':
                switch (type) {
                    case FieldTypes.UINT8:
                        this._value = value;
                        break;
                    case FieldTypes.UINT16:
                        this._value = value;
                        break;
                    case FieldTypes.UINT32:
                        this._value = value;
                        break;
                    case FieldTypes.UINT64:
                        if (isUInt64RangeValid(value))
                            this._value = value;
                        else
                            throw ErrMsg(EC.SERIALIZE_INVALID_UINT64);
                        break;
                    case FieldTypes.TIMESTAMP:
                        if (isUInt64RangeValid(value))
                            this._value = value;
                        else
                            throw ErrMsg(EC.SERIALIZE_INVALID_TIMESTAMP);
                        break;
                    case FieldTypes.INT8:
                        this._value = value;
                        break;
                    case FieldTypes.INT16:
                        this._value = value;
                        break;
                    case FieldTypes.INT32:
                        this._value = value;
                        break;
                    case FieldTypes.INT64:
                        if (isInt64RangeValid(value))
                            this._value = value;
                        else
                            throw ErrMsg(EC.SERIALIZE_INVALID_INT64);
                        break;
                    case FieldTypes.FLOAT:
                        this._value = value;
                        break;
                    case FieldTypes.DOUBLE:
                        this._value = value;
                        break;
                    case FieldTypes.DECIMAL:
                        this._value = value;
                        break;
                    case undefined:
                        throw ErrMsg(EC.SERIALIZE_TYPE_UNDEFINED);
                    default:
                        throw ErrMsg(EC.SERIALIZE_TYPE_MISMATCH);
                }
                this._type = type;
                break;
            case 'string':
                switch (type) {
                    case FieldTypes.SSTRING:
                        this._value = value;
                        break;
                    case FieldTypes.LSTRING:
                        this._value = value;
                        break;
                    case FieldTypes.UINT64:
                        if (isUInt64(value))
                            this._value = value;
                        else
                            throw ErrMsg(EC.SERIALIZE_INVALID_UINT64);
                        break;
                    case FieldTypes.TIMESTAMP:
                        if (isUInt64(value))
                            this._value = value;
                        else
                            throw ErrMsg(EC.SERIALIZE_INVALID_TIMESTAMP);
                        break;
                    case FieldTypes.INT64:
                        if (isInt64(value))
                            this._value = value;
                        else
                            throw ErrMsg(EC.SERIALIZE_INVALID_INT64);
                        break;
                    case undefined:
                        throw ErrMsg(EC.SERIALIZE_TYPE_UNDEFINED);
                    default:
                        throw ErrMsg(EC.SERIALIZE_TYPE_MISMATCH);
                }
                this._type = type;
                break;
            case 'object':
                if (value === null) {
                    this._value = null;
                    this._type = FieldTypes.VOID;
                } else if (value instanceof FieldTable) {
                    this._value = value;
                    this._type = FieldTypes.TABLE;
                } else if (value instanceof FieldArray) {
                    this._value = value;
                    this._type = FieldTypes.ARRAY;
                } else if (value instanceof FieldValue) {
                    this._value = value._value;
                    this._type = value._type;
                } else if (value instanceof Buffer) {
                    this._value = value;
                    this._type = FieldTypes.BYTES;
                } else {
                    throw ErrMsg(EC.SERIALIZE_TYPE_UNSUPPORTED);
                }
                break;
            default:
                throw ErrMsg(EC.SERIALIZE_TYPE_UNSUPPORTED);
        }

    }

    /**
     * @return {null|boolean|number|string|FieldArray|FieldTable|Buffer}
     */
    getValue() {
        return this._value;
    }

    /**
     * @return {!number}
     */
    getType() {
        return this._type;
    }

    /**
     * @return {null|boolean|number|string|Array|Object|Buffer}
     */
    toData() {
        switch (this._type) {
            case FieldTypes.TABLE:
                return this._value.toData();
            case FieldTypes.ARRAY:
                return this._value.toData();
            default:
                return this._value;
        }
    }

    /**
     * @param {!Decoder} decoder
     * @ignore
     * @override
     */
    deserialize(decoder) {

        const extType = decoder.readChar();
        const intType = decoder.behavior.fieldTypes.ext2int[extType];

        switch (intType) {
            case FieldTypes.BOOLEAN:
                this._value = (decoder.readUInt8() !== 0);
                break;
            case FieldTypes.TABLE:
                this._value = new FieldTable();
                this._value.deserialize(decoder);
                break;
            case FieldTypes.ARRAY:
                this._value = new FieldArray();
                this._value.deserialize(decoder);
                break;
            case FieldTypes.SSTRING:
                this._value = decoder.readShortString();
                break;
            case FieldTypes.LSTRING:
                this._value = decoder.readLongString();
                break;
            case FieldTypes.UINT8:
                this._value = decoder.readUInt8();
                break;
            case FieldTypes.UINT16:
                this._value = decoder.readUInt16();
                break;
            case FieldTypes.UINT32:
                this._value = decoder.readUInt32();
                break;
            case FieldTypes.UINT64:
                this._value = decoder.readUInt64();
                break;
            case FieldTypes.INT8:
                this._value = decoder.readInt8();
                break;
            case FieldTypes.INT16:
                this._value = decoder.readInt16();
                break;
            case FieldTypes.INT32:
                this._value = decoder.readInt32();
                break;
            case FieldTypes.INT64:
                this._value = decoder.readInt64();
                break;
            case FieldTypes.FLOAT:
                this._value = decoder.readFloat();
                break;
            case FieldTypes.DOUBLE:
                this._value = decoder.readDouble();
                break;
            case FieldTypes.DECIMAL:
                this._value = decoder.readDecimal();
                break;
            case FieldTypes.TIMESTAMP:
                this._value = decoder.readTimestamp();
                break;
            case FieldTypes.VOID:
                this._value = null;
                break;
            case FieldTypes.BYTES:
                this._value = decoder.readBytes();
                break;
            default:
                throw ErrMsg(EC.SERIALIZE_EXT_FIELD_TYPE_UNSUPPORTED, extType);
        }

        this._type = intType;

    }

    /**
     * @param {!Encoder} encoder
     * @ignore
     * @override
     */
    serialize(encoder) {

        const extType = encoder.behavior.fieldTypes.int2ext[this._type];

        if (extType === undefined) {
            throw ErrMsg(EC.SERIALIZE_INT_FIELD_TYPE_UNSUPPORTED, this._type);
        }

        encoder.writeChar(extType);
        switch (this._type) {
            case FieldTypes.BOOLEAN:
                encoder.writeUInt8(this._value ? 1 : 0);
                break;
            case FieldTypes.TABLE:
                this._value.serialize(encoder);
                break;
            case FieldTypes.ARRAY:
                this._value.serialize(encoder);
                break;
            case FieldTypes.SSTRING:
                encoder.writeShortString(this._value);
                break;
            case FieldTypes.LSTRING:
                encoder.writeLongString(this._value);
                break;
            case FieldTypes.UINT8:
                encoder.writeUInt8(this._value);
                break;
            case FieldTypes.UINT16:
                encoder.writeUInt16(this._value);
                break;
            case FieldTypes.UINT32:
                encoder.writeUInt32(this._value);
                break;
            case FieldTypes.UINT64:
                encoder.writeUInt64(this._value);
                break;
            case FieldTypes.INT8:
                encoder.writeInt8(this._value);
                break;
            case FieldTypes.INT16:
                encoder.writeInt16(this._value);
                break;
            case FieldTypes.INT32:
                encoder.writeInt32(this._value);
                break;
            case FieldTypes.INT64:
                encoder.writeInt64(this._value);
                break;
            case FieldTypes.FLOAT:
                encoder.writeFloat(this._value);
                break;
            case FieldTypes.DOUBLE:
                encoder.writeDouble(this._value);
                break;
            case FieldTypes.DECIMAL:
                encoder.writeDecimal(this._value);
                break;
            case FieldTypes.TIMESTAMP:
                encoder.writeTimestamp(this._value);
                break;
            case FieldTypes.VOID:
                break;
            case FieldTypes.BYTES:
                encoder.writeBytes(this._value);
                break;
        }

    }

}

/**
 *
 */
class FieldArray extends FieldLike {

    /**
     * @param {number=} size
     */
    constructor(size = 0) {
        super();

        /**
         * @private
         * @const {Array}
         */
        this._array = size ? new Array(size) : [];

        while (size) {
            this._array[--size] = new FieldValue();
        }
    }

    /**
     * @return {Array<null|boolean|number|string|Array|Object|Buffer>}
     */
    toData() {
        const data = new Array(this._array.length);
        this.forEach((value, index) => {
            data[index] = value.toData();
        });
        return data;
    }

    /**
     * @param {function(FieldValue, number, Array<FieldValue>, *=)} callback
     * @param {*=} parameter
     */
    forEach(callback, parameter) {
        this._array.forEach(callback, parameter);
    }

    // noinspection JSUnusedGlobalSymbols
    /**
     * @param {function(FieldValue, number, Array<FieldValue>, *=) : !boolean} callback
     * @param {*=} parameter
     * @return {Array<FieldValue>}
     */
    filter(callback, parameter) {
        return this._array.filter(callback, parameter);
    }

    /**
     * @return {!FieldValue}
     */
    shift() {
        return this._array.shift();
    }

    /**
     * @param {!FieldValue} value
     * @return {!number}
     */
    push(value) {
        if (value)
            return this._array.push(value);
        else
            return this._array.push(new FieldValue());          // be on the safe side
    }

    /**
     * @return {!FieldValue}
     */
    pop() {
        return this._array.pop();
    }

    /**
     * @param {!number} index
     * @return {?FieldValue}
     */
    find(index) {
        return index < this._array.length ? this._array[index] : null;
    }

    /**
     * @param {!number} index
     * @return {!FieldValue}
     */
    get(index) {
        while (index >= this._array.length) {
            this._array.push(new FieldValue());
        }
        return this._array[index];
    }

    // noinspection JSUnusedGlobalSymbols
    /**
     * @param {!number} size
     */
    resize(size) {
        this._array.length = size;
    }

    /**
     * @return {!number}
     */
    size() {
        return this._array.length;
    }

    /**
     * @param {!Decoder} decoder
     * @ignore
     * @override
     */
    deserialize(decoder) {
        this._array.length = 0;
        const inside = decoder.readBlockSizeUInt32();
        while (inside()) {
            const value = new FieldValue();
            value.deserialize(decoder);
            this.push(value);
        }
    }

    /**
     * @param {!Encoder} encoder
     * @ignore
     * @override
     */
    serialize(encoder) {
        const done = encoder.writeBlockSizeUInt32();
        this.forEach((value) => {
            value.serialize(encoder);
        });
        done();
    }

}

/**
 *
 */
class FieldTable extends FieldLike {

    /**
     * @param {Array<string>=} keys
     */
    constructor(keys = []) {
        super();

        /**
         * @type {Object<string, !FieldValue>}
         * @private
         */
        this._values = {};

        /**
         * initialize
         */
        for (const key of keys) this._values[key] = new FieldValue();
    }

    /**
     * @return {Object<string,null|boolean|number|string|Array|Object|Buffer>}
     */
    toData() {
        const data = {};
        this.forEach((key, value) => {
            data[key] = value.toData();
        });
        return data;
    }

    /**
     * @param {function(!string, !FieldValue)} callback
     */
    forEach(callback) {
        Object.keys(this._values).forEach((key) => {
            callback(key, this._values[key]);
        });
    }

    /**
     * @param {!string} key
     * @return {!FieldValue}
     */
    insert(key) {
        const value = new FieldValue();
        this._values[key] = value;
        return value;
    }

    /**
     * @param {!string} key
     * @return {?FieldValue}
     */
    find(key) {
        const value = this._values[key];
        return (value === null || value === undefined) ? null : value;
    }

    /**
     * @param {!string} key
     * @return {!FieldValue}
     */
    get(key) {
        let value = this._values[key];
        if (value === null || value === undefined) {
            value = new FieldValue();
            this._values[key] = value;
        }
        return value;
    }

    /**
     * @param {!string} key
     */
    remove(key) {
        delete this._values[key];
    }

    /**
     * @param {!Decoder} decoder
     * @ignore
     * @override
     */
    deserialize(decoder) {
        this._values = /** @dict */ {};
        const inside = decoder.readBlockSizeUInt32();
        while (inside()) {
            const key = decoder.readShortString();
            const value = new FieldValue();
            value.deserialize(decoder);
            this._values[key] = value;
        }
    }

    /**
     * @param {!Encoder} encoder
     * @ignore
     * @override
     */
    serialize(encoder) {
        const done = encoder.writeBlockSizeUInt32();
        this.forEach((key, value) => {
            encoder.writeShortString(key);
            value.serialize(encoder);
        });
        done();
    }

}

module.exports = {
    Properties: Properties,
    Method: Method,
    MethodContent: MethodContent,
    MethodFactory: MethodFactory,
    Payload: Payload,
    FieldTypes: FieldTypes,
    FieldValue: FieldValue,
    FieldArray: FieldArray,
    FieldTable: FieldTable,
};

