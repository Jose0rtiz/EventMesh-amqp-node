'use strict';

const { EC, ErrMsg } = require('../errors');
const { readUInt64BE, readInt64BE } = require('../tools/bignum');
const { Method, MethodContent } = require('./types.js');

const constants = require('./constants');
const HEARTBEAT = constants.FRAME.TYPE.HEARTBEAT;
const METHOD    = constants.FRAME.TYPE.METHOD;
const HEADER    = constants.FRAME.TYPE.HEADER;
const BODY      = constants.FRAME.TYPE.BODY;
const END       = constants.FRAME.CODE.END;
const HEADSIZE  = constants.FRAME.SIZE.HEADER;
const ENDSIZE   = constants.FRAME.SIZE.END;

/*
 *   0      1         3             7                   size+7 size+8
 *   +------+---------+-------------+   +-----------+   +-----------+
 *   | type | channel |     size    |   |  payload  |   | frame-end |
 *   +------+---------+-------------+   +-----------+   +-----------+
 *    octet    short        long         size octets        octet
 */

/**
 * @callback BlockCheck
 * @return {boolean}
 * @private
 */

/**
 * @private
 */
class Decoder {

    /**
     * @param {!Behavior} behavior
     * @param {!MethodFactory} factory
     * @param {!MethodHandler} onMethod
     * @param {!HeartbeatHandler} onHeartbeat
     */
    constructor(behavior, factory, onMethod, onHeartbeat) {

        /**
         * @type {number}
         */
        this.statChunkCount = 0;

        /**
         * @type {number}
         */
        this.statFrameCount = 0;

        /**
         * @type {number}
         */
        this.statMethodCount = 0;

        /**
         * @type {!Behavior}
         */
        this.behavior = behavior;

        /**
         * @type {!MethodFactory}
         * @private
         */
        this._factory = factory;

        /**
         * @type {!HeartbeatHandler}
         * @private
         */
        this._onHeartbeat = onHeartbeat;

        /**
         * @type {!MethodHandler}
         * @private
         */
        this._onMethod = onMethod;

        /**
         * @type {!Map<number, {}>}
         * @private
         */
        this._buildBuffer = new Map();

        /**
         * @type {number}
         * @private
         */
        this._frameType = null;

        /**
         * @type {number}
         * @private
         */
        this._channelID = null;

        /**
         * @type {number}
         * @private
         */
        this._frameSize = null;

        /**
         * @type {number}
         * @private
         */
        this._frameConsumed = 0;

        /**
         * @type {number}
         * @private
         */
        this._inputAvailable = 0;

        /**
         * @type {!Array<!Buffer>}
         * @private
         */
        this._inputQueue = new Array(0);

        /**
         * @type {number}
         * @private
         */
        this._chunkAvailable = 0;

        /**
         * @type {number}
         * @private
         */
        this._chunkConsumed = 0;

        /**
         * @type {number}
         * @private
         */
        this._chunkOffset = 0;

        /**
         * @type {!Buffer}
         * @private
         */
        this._chunkReading = null;

    }

    /**
     *
     */
    stop() {
        this._read = nop;
    }

    /**
     * @param {!Buffer} chunk
     */
    push(chunk) {
        if (chunk.length === 0) {
            return;
        } else if (this._inputAvailable === 0) {
            this._inputAvailable = chunk.length;
            this._chunkAvailable = chunk.length;
            this._chunkConsumed = 0;
            this._chunkOffset = 0;
            this._chunkReading = chunk;
        } else {
            this._inputQueue.push(chunk);
            this._inputAvailable += chunk.length;
        }
        ++this.statChunkCount;
        this._read();
    }

    /**
     * @private
     */
    _read() {
        while (this._inputAvailable > 0) {
            if (this._frameConsumed === 0) {
                if (this._inputAvailable < HEADSIZE) return;
                this._frameType = this.readUInt8();
                this._channelID = this.readUInt16();
                this._frameSize = this.readUInt32();
            }
            if (this._frameSize > this.behavior.maxFrameSize) {
                throw ErrMsg(EC.FRAME_EXCEEDS_SIZE, this._frameSize, this.behavior.maxFrameSize);
            }
            if (this._inputAvailable < (this._frameSize + ENDSIZE)) {
                return;
            }

            let buffer = this._buildBuffer.get(this._channelID);
            if (!buffer) {
                buffer = {method: undefined, complete: false, headSize: 0, bodySize: 0};
                this._buildBuffer.set(this._channelID, buffer);
            }

            switch (this._frameType) {
                case METHOD:
                    if (buffer.method)
                        throw ErrMsg(EC.FRAME_METHOD_UNEXPECTED);

                    const classMethodID = this.readUInt32();
                    buffer.method = this._factory.createMethod(classMethodID);
                    buffer.method.deserialize(this);
                    buffer.method.channelID = this._channelID;

                    buffer.complete = !(buffer.method instanceof MethodContent);
                    buffer.headSize = null;
                    buffer.bodySize = null;

                    break;
                case HEADER:
                    if (!buffer.method)
                        throw ErrMsg(EC.FRAME_HEADER_UNEXPECTED_METHOD);
                    if (buffer.headSize !== null)
                        throw ErrMsg(EC.FRAME_HEADER_UNEXPECTED_HEADER);

                    const classID = this.readUInt16();
                    // noinspection JSUnusedLocalSymbols
                    const weight = this.readUInt16();
                    buffer.headSize = this.readUInt64();
                    buffer.method.properties.deserialize(this, buffer.method.payload);

                    buffer.bodySize = 0;
                    buffer.complete = (buffer.headSize === 0);

                    const bufferClassID = Method.classID(buffer.method.classMethodID);
                    if (classID !== bufferClassID)
                        throw ErrMsg(EC.FRAME_HEADER_CLASS_MISMATCH, bufferClassID, classID);

                    break;
                case BODY:
                    if (!buffer.method)
                        throw ErrMsg(EC.FRAME_BODY_UNEXPECTED_METHOD);
                    if (buffer.headSize === null)
                        throw ErrMsg(EC.FRAME_BODY_UNEXPECTED_HEADER);

                    this._readDataBlobArray(buffer.method.payload.chunks, this._frameSize);
                    buffer.bodySize += this._frameSize;
                    buffer.complete = (buffer.headSize === buffer.bodySize);

                    if (buffer.bodySize > buffer.headSize)
                        throw ErrMsg(EC.FRAME_BODY_UNEXPECTED_HEADER);

                    break;
                case HEARTBEAT:
                    this._onHeartbeat();
                    break;
                default:
                    throw ErrMsg(EC.FRAME_TYPE_INVALID);
            }

            const readSize = this._frameConsumed - HEADSIZE;
            if (this._frameSize !== readSize)
                throw ErrMsg(EC.FRAME_SIZE_MISMATCH, this._frameSize, readSize);

            const endCode = this.readUInt8();
            if (endCode !== END)
                throw ErrMsg(EC.FRAME_END_NOT_FOUND);

            this._frameConsumed = 0;
            this.statFrameCount += 1;

            if (buffer.complete) {
                this.statMethodCount += 1;
                this._onMethod(buffer.method);
                buffer.method = null;
                buffer.complete = false;
            }
        }

        if (this._inputAvailable === 0 && this._frameConsumed === 0) {  // no further data and no incomplete frame
            this._chunkAvailable = 0;                                   // keep build buffer, but free last chunk
            this._chunkConsumed = 0;
            this._chunkOffset = 0;
            this._chunkReading = null;
        }
    }

    /**
     * @param {number} length
     * @private
     */
    _reading(length) {
        if(length > this._inputAvailable)
            throw ErrMsg(EC.FRAME_BYTES);
        if(length > this._chunkAvailable)
            this._readingMore(length);
        this._chunkOffset = this._chunkConsumed;
        this._chunkConsumed += length;
        this._chunkAvailable -= length;
        this._frameConsumed += length;
        this._inputAvailable -= length;
    }

    /**
     * @param {number} length
     * @private
     */
    _readingMore(length) {
        if (this._chunkAvailable === 0 && length <= this._inputQueue[0].length) {
            this._chunkReading = this._inputQueue.shift();
            this._chunkAvailable = this._chunkReading.length;
        } else {
            this._readingMoreConcat(length);
        }
        this._chunkConsumed = 0;
    }

    /**
     * @param {number} length
     * @private
     */
    _readingMoreConcat(length) {
        const chunks = [];
        if (this._chunkAvailable > 0) {
            chunks.push(this._chunkReading.slice(this._chunkConsumed));
        }
        while (this._chunkAvailable < length) {
            const miss = length - this._chunkAvailable, next = this._inputQueue[0], nlen = next.length;
            if (miss >= nlen || (miss > 42 && nlen < 256)) {
                this._chunkAvailable += nlen;
                chunks.push(this._inputQueue.shift());
            } else {
                this._chunkAvailable += miss;
                chunks.push(next.slice(0, miss));
                this._inputQueue[0] = next.slice(miss);
            }
        }
        this._chunkReading = chunks.length > 1 ? Buffer.concat(chunks, this._chunkAvailable) : chunks[0];
    }

    /**
     * @param {number} size
     * @return {!Buffer}
     * @private
     */
    _readDataBlob(size) {
        this._reading(size);
        return (size === this._chunkReading.length) ? this._chunkReading : this._chunkReading.slice(this._chunkOffset, this._chunkOffset + size);
    }

    /**
     * @param {!Array<!Buffer>} target
     * @param {number} length
     * @private
     */
    _readDataBlobArray(target, length) {
        while (length > 0) {
            if(this._chunkAvailable === 0) {
                const size = Math.min(length, this._inputQueue[0].length);
                target.push(this._readDataBlob(size));
                length -= size;
            } else if (length > this._chunkAvailable) {
                const size = this._chunkAvailable;
                target.push(this._readDataBlob(size));
                length -= size;
            } else {
                target.push(this._readDataBlob(length));
                length = 0;
            }
        }
    }

    /**
     * @return {BlockCheck}
     */
    readBlockSizeUInt32() {
        const end = this.readUInt32() + this._frameConsumed; // keep sequence: read, then use updated _frameConsumed
        return () => {
            if(this._frameConsumed < end) {
                return true;
            }
            if (this._frameConsumed === end) {
                return false;
            }
            throw ErrMsg(EC.FRAME_EXCEEDS_BLOCKS_SIZE, (this._frameConsumed - end));
        };
    }

    /**
     * @return {number}
     */
    readUInt8() {
        this._reading(1);
        return this._chunkReading.readUInt8(this._chunkOffset);
    }

    /**
     * @return {number}
     */
    readUInt16() {
        this._reading(2);
        return this._chunkReading.readUInt16BE(this._chunkOffset);
    }

    /**
     * @return {number}
     */
    readUInt32() {
        this._reading(4);
        return this._chunkReading.readUInt32BE(this._chunkOffset);
    }

    /**
     * @return {number}
     */
    readUInt64() {
        this._reading(8);
        return readUInt64BE(this._chunkReading, this._chunkOffset);
    }

    /**
     * @return {number}
     */
    readInt8() {
        this._reading(1);
        return this._chunkReading.readInt8(this._chunkOffset);
    }

    /**
     * @return {number}
     */
    readInt16() {
        this._reading(2);
        return this._chunkReading.readInt16BE(this._chunkOffset);
    }

    /**
     * @return {number}
     */
    readInt32() {
        this._reading(4);
        return this._chunkReading.readInt32BE(this._chunkOffset);
    }

    /**
     * @return {number}
     */
    readInt64() {
        this._reading(8);
        return readInt64BE(this._chunkReading, this._chunkOffset);
    }

    /**
     * @return {number}
     */
    readFloat() {
        this._reading(4);                       // 32 bit float
        return this._chunkReading.readFloatBE(this._chunkOffset);
    }

    /**
     * @return {number}
     */
    readDouble() {
        this._reading(8);                       // 64 bit double
        return this._chunkReading.readDoubleBE(this._chunkOffset);
    }

    /**
     * @return {number}
     */
    readDecimal() {
        const dec = this.readUInt8();
        const num = this.readInt32();
        return dec === 0 ? num : num / Math.pow(10, dec);
    }

    /**
     * @return {number}
     */
    readTimestamp() {
        this._reading(8);
        return readUInt64BE(this._chunkReading, this._chunkOffset);
    }

    /**
     * @return {string}
     */
    readChar() {
        this._reading(1);
        return this._chunkReading.toString('utf8', this._chunkOffset, this._chunkOffset + 1);
    }

    /**
     * @return {?string}
     */
    readShortString() {
        const length = this.readUInt8();
        if(length > 0) {
            this._reading(length);
            return this._chunkReading.toString('utf8', this._chunkOffset, this._chunkOffset + length);
        } else {
            return null;
        }
    }

    /**
     * @return {?string}
     */
    readLongString() {
        const length = this.readUInt32();
        if(length > 0) {
            this._reading(length);
            return this._chunkReading.toString('utf8', this._chunkOffset, this._chunkOffset + length);
        } else {
            return null;
        }
    }

    /**
     * @param {number} count of bits to read
     * @return {Array.<boolean>}
     */
    readBitSet8Inverse(count) {
        const bitSet = this.readUInt8();
        const result = new Array(count);
        for(let i = 0; i < count; ++i) {
            result[i] = !!(bitSet & (1 << i));
        }
        return result;
    }

    /**
     * @param {number} count
     * @return {Array.<boolean>}
     */
    readBitSet16(count) {
        const bitSet = this.readUInt16();
        const result = new Array(count);
        let bitMask = 1 << 15;
        for(let i = 0; i < count; ++i) {
            result[i] = !!(bitSet & bitMask);
            bitMask >>>= 1;
        }
        return result;
    }

    /**
     * @return {Buffer}
     */
    readBytes() {
        const length = this.readUInt32();
        this._reading(length);
        return this._chunkReading.slice(this._chunkOffset, this._chunkOffset + length);
    }

}

/**
 * @param {*=} result
 * @return {*}
 * @private
 */
function nop(result) { return result; }

module.exports = {
    Decoder : Decoder
};

