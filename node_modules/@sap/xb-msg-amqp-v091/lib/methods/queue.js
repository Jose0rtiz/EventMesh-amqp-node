'use strict';

const { Method, FieldTable } = require('../serialize/types');

const constants = require('../serialize/constants');
const DECLARE = constants.METHOD.QUEUE.DECLARE;
const DECLARE_OK = constants.METHOD.QUEUE.DECLARE_OK;
const BIND = constants.METHOD.QUEUE.BIND;
const BIND_OK = constants.METHOD.QUEUE.BIND_OK;
const UNBIND = constants.METHOD.QUEUE.UNBIND;
const UNBIND_OK = constants.METHOD.QUEUE.UNBIND_OK;
const PURGE = constants.METHOD.QUEUE.PURGE;
const PURGE_OK = constants.METHOD.QUEUE.PURGE_OK;
const DELETE = constants.METHOD.QUEUE.DELETE;
const DELETE_OK = constants.METHOD.QUEUE.DELETE_OK;

const EMPTY_FIELD_TABLE = new FieldTable();

/**
 * @struct
 * @private
 */
class QueueDeclare extends Method {

    constructor() {
        super(DECLARE);

        /**
         * @type {?string}
         */
        this.queue = null;

        /**
         * @type {boolean}
         */
        this.passive = false;

        /**
         * @type {boolean}
         */
        this.durable = false;

        /**
         * @type {boolean}
         */
        this.exclusive = false;

        /**
         * @type {boolean}
         */
        this.autoDelete = false;

        /**
         * @type {boolean}
         */
        this.noWait = false;

        /**
         * @type {!FieldTable}
         */
        this.args = null;
    }

    /**
     * @param {!Decoder} decoder
     * @override
     */
    deserialize(decoder) {
        // noinspection JSUnusedLocalSymbols
        let reserved = decoder.readUInt16();
        this.queue = decoder.readShortString();
        const bitSet = decoder.readBitSet8Inverse(5);
        this.passive = bitSet[0];
        this.durable = bitSet[1];
        this.exclusive = bitSet[2];
        this.autoDelete = bitSet[3];
        this.noWait = bitSet[4];
        this.args = new FieldTable();
        this.args.deserialize(decoder);
    }

    /**
     * @param {!Encoder} encoder
     * @override
     */
    serialize(encoder) {
        const reserved = 0;
        encoder.writeUInt16(reserved);
        encoder.writeShortString(this.queue);
        encoder.writeBitSet8Inverse(this.passive, this.durable, this.exclusive, this.autoDelete, this.noWait);
        if (this.args) {
            this.args.serialize(encoder);
        } else {
            EMPTY_FIELD_TABLE.serialize(encoder);
        }
    }

}

/**
 * @struct
 * @private
 */
class QueueDeclareOk extends Method {

    constructor() {
        super(DECLARE_OK, DECLARE);

        /**
         * @type {?string}
         */
        this.queue = null;

        /**
         * @type {?number}
         */
        this.messageCount = null;

        /**
         * @type {?number}
         */
        this.consumerCount = null;
    }

    /**
     * @param {!Decoder} decoder
     * @override
     */
    deserialize(decoder) {
        this.queue = decoder.readShortString();
        this.messageCount = decoder.readUInt32();
        this.consumerCount = decoder.readUInt32();
    }

    /**
     * @param {!Encoder} encoder
     * @override
     */
    serialize(encoder) {
        encoder.writeShortString(this.queue);
        encoder.writeUInt32(this.messageCount);
        encoder.writeUInt32(this.consumerCount);
    }

}

/**
 * @struct
 * @private
 */
class QueueBind extends Method {

    constructor() {
        super(BIND);

        /**
         * @type {?string}
         */
        this.queue = null;

        /**
         * @type {?string}
         */
        this.exchange = null;

        /**
         * @type {?string}
         */
        this.routingKey = null;

        /**
         * @type {boolean}
         */
        this.noWait = false;

        /**
         * @type {!FieldTable}
         */
        this.args = null;
    }

    /**
     * @param {!Decoder} decoder
     * @override
     */
    deserialize(decoder) {
        // noinspection JSUnusedLocalSymbols
        let reserved = decoder.readUInt16();
        this.queue = decoder.readShortString();
        this.exchange = decoder.readShortString();
        this.routingKey = decoder.readShortString();
        const bitSet = decoder.readBitSet8Inverse(1);
        this.noWait = bitSet[0];
        this.args = new FieldTable();
        this.args.deserialize(decoder);
    }

    /**
     * @param {!Encoder} encoder
     * @override
     */
    serialize(encoder) {
        const reserved = 0;
        encoder.writeUInt16(reserved);
        encoder.writeShortString(this.queue);
        encoder.writeShortString(this.exchange);
        encoder.writeShortString(this.routingKey);
        encoder.writeBitSet8Inverse(this.noWait);
        if (this.args) {
            this.args.serialize(encoder);
        } else {
            EMPTY_FIELD_TABLE.serialize(encoder);
        }
    }

}

/**
 * @struct
 * @private
 */
class QueueBindOk extends Method {

    constructor() {
        super(BIND_OK, BIND);
    }

    /**
     * @param {!Decoder} decoder
     * @override
     */
    deserialize(decoder) {
    }

    /**
     * @param {!Encoder} encoder
     * @override
     */
    serialize(encoder) {
    }

}

/**
 * @struct
 * @private
 */
class QueueUnbind extends Method {

    constructor() {
        super(UNBIND);

        /**
         * @type {?string}
         */
        this.queue = null;

        /**
         * @type {?string}
         */
        this.exchange = null;

        /**
         * @type {?string}
         */
        this.routingKey = null;

        /**
         * @type {!FieldTable}
         */
        this.args = null;
    }

    /**
     * @param {!Decoder} decoder
     * @override
     */
    deserialize(decoder) {
        // noinspection JSUnusedLocalSymbols
        let reserved = decoder.readUInt16();
        this.queue = decoder.readShortString();
        this.exchange = decoder.readShortString();
        this.routingKey = decoder.readShortString();
        this.args = new FieldTable();
        this.args.deserialize(decoder);
    }

    /**
     * @param {!Encoder} encoder
     * @override
     */
    serialize(encoder) {
        const reserved = 0;
        encoder.writeUInt16(reserved);
        encoder.writeShortString(this.queue);
        encoder.writeShortString(this.exchange);
        encoder.writeShortString(this.routingKey);
        if (this.args) {
            this.args.serialize(encoder);
        } else {
            EMPTY_FIELD_TABLE.serialize(encoder);
        }
    }
}

/**
 * @struct
 * @private
 */
class QueueUnbindOk extends Method {

    constructor() {
        super(UNBIND_OK, UNBIND);
    }

    /**
     * @param {!Decoder} decoder
     * @override
     */
    deserialize(decoder) {
    }

    /**
     * @param {!Encoder} encoder
     * @override
     */
    serialize(encoder) {
    }

}

/**
 * @struct
 * @private
 */
class QueuePurge extends Method {

    constructor() {
        super(PURGE);

        /**
         * @type {?string}
         */
        this.queue = null;

        /**
         * @type {boolean}
         */
        this.noWait = false;
    }

    /**
     * @param {!Decoder} decoder
     * @override
     */
    deserialize(decoder) {
        // noinspection JSUnusedLocalSymbols
        let reserved = decoder.readUInt16();
        this.queue = decoder.readShortString();
        const bitSet = decoder.readBitSet8Inverse(1);
        this.noWait = bitSet[0];
    }

    /**
     * @param {!Encoder} encoder
     * @override
     */
    serialize(encoder) {
        const reserved = 0;
        encoder.writeUInt16(reserved);
        encoder.writeShortString(this.queue);
        encoder.writeBitSet8Inverse(this.noWait);
    }

}

/**
 * @struct
 * @private
 */
class QueuePurgeOk extends Method {

    constructor() {
        super(PURGE_OK, PURGE);

        /**
         * @type {?number}
         */
        this.messageCount = null;
    }

    /**
     * @param {!Decoder} decoder
     * @override
     */
    deserialize(decoder) {
        this.messageCount = decoder.readUInt32();
    }

    /**
     * @param {!Encoder} encoder
     * @override
     */
    serialize(encoder) {
        encoder.writeUInt32(this.messageCount);
    }
}

/**
 * @struct
 * @private
 */
class QueueDelete extends Method {

    constructor() {
        super(DELETE);

        /**
         * @type {?string}
         */
        this.queue = null;

        /**
         * @type {boolean}
         */
        this.ifUnused = false;

        /**
         * @type {boolean}
         */
        this.ifEmpty = false;

        /**
         * @type {boolean}
         */
        this.noWait = false;
    }

    /**
     * @param {!Decoder} decoder
     * @override
     */
    deserialize(decoder) {
        // noinspection JSUnusedLocalSymbols
        let reserved = decoder.readUInt16();
        this.queue = decoder.readShortString();
        const bitSet = decoder.readBitSet8Inverse(3);
        this.ifUnused = bitSet[0];
        this.ifEmpty = bitSet[1];
        this.noWait = bitSet[2];
    }

    /**
     * @param {!Encoder} encoder
     * @override
     */
    serialize(encoder) {
        const reserved = 0;
        encoder.writeUInt16(reserved);
        encoder.writeShortString(this.queue);
        encoder.writeBitSet8Inverse(this.ifUnused, this.ifEmpty, this.noWait);
    }

}

/**
 * @struct
 * @private
 */
class QueueDeleteOk extends Method {

    constructor() {
        super(DELETE_OK, DELETE);

        /**
         * @type {?number}
         */
        this.messageCount = null;
    }

    /**
     * @param {!Decoder} decoder
     * @override
     */
    deserialize(decoder) {
        this.messageCount = decoder.readUInt32();
    }

    /**
     * @param {!Encoder} encoder
     * @override
     */
    serialize(encoder) {
        encoder.writeUInt32(this.messageCount);
    }
}

module.exports = {
    Declare : QueueDeclare,
    DeclareOk : QueueDeclareOk,
    Bind : QueueBind,
    BindOk : QueueBindOk,
    Unbind : QueueUnbind,
    UnbindOk : QueueUnbindOk,
    Purge : QueuePurge,
    PurgeOk : QueuePurgeOk,
    Delete : QueueDelete,
    DeleteOk : QueueDeleteOk
};

