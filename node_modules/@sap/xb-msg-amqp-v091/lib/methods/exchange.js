'use strict';

const { Method, FieldTable } = require('../serialize/types');

const constants = require('../serialize/constants');
const DECLARE = constants.METHOD.EXCHANGE.DECLARE;
const DECLARE_OK = constants.METHOD.EXCHANGE.DECLARE_OK;
const DELETE = constants.METHOD.EXCHANGE.DELETE;
const DELETE_OK = constants.METHOD.EXCHANGE.DELETE_OK;
const BIND = constants.METHOD.EXCHANGE.BIND;
const BIND_OK = constants.METHOD.EXCHANGE.BIND_OK;
const UNBIND = constants.METHOD.EXCHANGE.UNBIND;
const UNBIND_OK = constants.METHOD.EXCHANGE.UNBIND_OK;

const EMPTY_FIELD_TABLE = new FieldTable();

/**
 * @struct
 * @private
 */
class ExchangeDeclare extends Method {

    constructor() {
        super(DECLARE);

        /**
         * @type {?string}
         */
        this.exchange = null;

        /**
         * @type {?string}
         */
        this.type = null;

        /**
         * @type {boolean}
         */
        this.passive = false;

        /**
         * @type {boolean}
         */
        this.durable = false;

        /**
         * @type {boolean}
         */
        this.noWait = false;

        /**
         * @type {?FieldTable}
         */
        this.args = null;
    }

    /**
     * @param {!Decoder} decoder
     * @override
     */
    deserialize(decoder) {
        // noinspection JSUnusedLocalSymbols
        let reserved = decoder.readUInt16();
        this.exchange = decoder.readShortString();
        this.type = decoder.readShortString();
        let bitSet = decoder.readBitSet8Inverse(5);
        this.passive = bitSet[0];
        this.durable = bitSet[1];
        this.noWait = bitSet[4];
        this.args = new FieldTable();
        this.args.deserialize(decoder);
    }

    /**
     * @param {!Encoder} encoder
     * @override
     */
    serialize(encoder) {
        const reserved = 0;
        encoder.writeUInt16(reserved);
        encoder.writeShortString(this.exchange);
        encoder.writeShortString(this.type);
        encoder.writeBitSet8Inverse(this.passive, this.durable, false, false, this.noWait);
        if (this.args) {
            this.args.serialize(encoder);
        } else {
            EMPTY_FIELD_TABLE.serialize(encoder);
        }
    }
}

/**
 * @struct
 * @private
 */
class ExchangeDeclareOk extends Method {

    constructor() {
        super(DECLARE_OK, DECLARE);
    }

    /**
     * @param {!Decoder} decoder
     * @override
     */
    deserialize(decoder) {
    }

    /**
     * @param {!Encoder} encoder
     * @override
     */
    serialize(encoder) {
    }

}

/**
 * @struct
 * @private
 */
class ExchangeBind extends Method {

    constructor() {
        super(BIND);

        /**
         * @type {?string}
         */
        this.destination = null;

        /**
         * @type {?string}
         */
        this.source = null;

        /**
         * @type {?string}
         */
        this.routingKey = null;

        /**
         * @type {boolean}
         */
        this.noWait = false;

        /**
         * @type {?FieldTable}
         */
        this.args = null;
    }

    /**
     * @param {!Decoder} decoder
     * @override
     */
    deserialize(decoder) {
        // noinspection JSUnusedLocalSymbols
        let reserved = decoder.readUInt16();
        this.destination = decoder.readShortString();
        this.source = decoder.readShortString();
        this.routingKey = decoder.readShortString();
        const bitSet = decoder.readBitSet8Inverse(1);
        this.noWait = bitSet[0];
        this.args = new FieldTable();
        this.args.deserialize(decoder);
    }

    /**
     * @param {!Encoder} encoder
     * @override
     */
    serialize(encoder) {
        const reserved = 0;
        encoder.writeUInt16(reserved);
        encoder.writeShortString(this.destination);
        encoder.writeShortString(this.source);
        encoder.writeShortString(this.routingKey);
        encoder.writeBitSet8Inverse(this.noWait);
        if (this.args) {
            this.args.serialize(encoder);
        } else {
            EMPTY_FIELD_TABLE.serialize(encoder);
        }
    }

}

/**
 * @struct
 * @private
 */
class ExchangeBindOk extends Method {

    constructor() {
        super(BIND_OK, BIND);
    }

    /**
     * @param {!Decoder} decoder
     * @override
     */
    deserialize(decoder) {
    }

    /**
     * @param {!Encoder} encoder
     * @override
     */
    serialize(encoder) {
    }

}

/**
 * @struct
 * @private
 */
class ExchangeUnbind extends Method {

    constructor() {
        super(UNBIND);

        /**
         * @type {?string}
         */
        this.destination = null;

        /**
         * @type {?string}
         */
        this.source = null;

        /**
         * @type {?string}
         */
        this.routingKey = null;

        /**
         * @type {boolean}
         */
        this.noWait = false;

        /**
         * @type {?FieldTable}
         */
        this.args = null;
    }

    /**
     * @param {!Decoder} decoder
     * @override
     */
    deserialize(decoder) {
        // noinspection JSUnusedLocalSymbols
        let reserved = decoder.readUInt16();
        this.destination = decoder.readShortString();
        this.source = decoder.readShortString();
        this.routingKey = decoder.readShortString();
        const bitSet = decoder.readBitSet8Inverse(1);
        this.noWait = bitSet[0];
        this.args = new FieldTable();
        this.args.deserialize(decoder);
    }

    /**
     * @param {!Encoder} encoder
     * @override
     */
    serialize(encoder) {
        const reserved = 0;
        encoder.writeUInt16(reserved);
        encoder.writeShortString(this.destination);
        encoder.writeShortString(this.source);
        encoder.writeShortString(this.routingKey);
        encoder.writeBitSet8Inverse(this.noWait);
        if (this.args) {
            this.args.serialize(encoder);
        } else {
            EMPTY_FIELD_TABLE.serialize(encoder);
        }
    }

}

/**
 * @struct
 * @private
 */
class ExchangeUnbindOk extends Method {

    constructor() {
        super(UNBIND_OK, UNBIND);
    }

    /**
     * @param {!Decoder} decoder
     * @override
     */
    deserialize(decoder) {
    }

    /**
     * @param {!Encoder} encoder
     * @override
     */
    serialize(encoder) {
    }

}

/**
 * @struct
 * @private
 */
class ExchangeDelete extends Method {

    constructor() {
        super(DELETE);

        /**
         * @type {?string}
         */
        this.exchange = null;

        /**
         * @type {boolean}
         */
        this.ifUnused = false;

        /**
         * @type {boolean}
         */
        this.noWait = false;
    }

    /**
     * @param {!Decoder} decoder
     * @override
     */
    deserialize(decoder) {
        // noinspection JSUnusedLocalSymbols
        let reserved = decoder.readUInt16();
        this.exchange = decoder.readShortString();
        const bitSet = decoder.readBitSet8Inverse(2);
        this.ifUnused = bitSet[0];
        this.noWait = bitSet[1];
    }

    /**
     * @param {!Encoder} encoder
     * @override
     */
    serialize(encoder) {
        const reserved = 0;
        encoder.writeUInt16(reserved);
        encoder.writeShortString(this.exchange);
        encoder.writeBitSet8Inverse(this.ifUnused, this.noWait);
    }

}

/**
 * @struct
 * @private
 */
class ExchangeDeleteOk extends Method {

    constructor() {
        super(DELETE_OK, DELETE);
    }

    /**
     * @param {!Decoder} decoder
     * @override
     */
    deserialize(decoder) {
    }

    /**
     * @param {!Encoder} encoder
     * @override
     */
    serialize(encoder) {
    }

}

module.exports = {
    Declare : ExchangeDeclare,
    DeclareOk : ExchangeDeclareOk,
    Bind : ExchangeBind,
    BindOk : ExchangeBindOk,
    Unbind : ExchangeUnbind,
    UnbindOk : ExchangeUnbindOk,
    Delete : ExchangeDelete,
    DeleteOk : ExchangeDeleteOk
};

