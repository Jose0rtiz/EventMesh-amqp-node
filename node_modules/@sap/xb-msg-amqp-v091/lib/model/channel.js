'use strict';

const EventEmitter = require('events');
const { EC, ErrMsg } = require('../errors');
const { Method } = require('../serialize/types');
const { Model } = require('../methods/model');
const { Exchange } = require('./exchange');
const { Queue } = require('./queue');

const constants = require('../serialize/constants');
const CLOSE = constants.METHOD.CHANNEL.CLOSE;
const RETURN = constants.METHOD.BASIC.RETURN;

/**
 * @enum {number}
 * @private
 */
const STATE = Object.freeze({
    OPENING : 0x01,
    OPENED  : 0x02,
    CLOSING : 0x03,
    CLOSED  : 0x04
});

/**
 * The channel proxy class.
 */
class Channel extends EventEmitter {

    /**
     * The channel is opened now and can be used
     * @event Channel#opened
     */

    /**
     * The channel has been switched into confirm mode.
     * @event Channel#confirms
     */

    /**
     * The channel flow mode has changed.
     * @event Channel#flow
     * @param {boolean} active - Indicator whether or not data can flow
     */

    /**
     * A warning that a (mandatory) message could not be delivered.
     * @event Channel#return
     * @param {number} code - Error code
     * @param {string} text - Error text
     * @param {string} exchange - Exchange name
     * @param {string} routingKey - Routing key
     * @param {?Object} properties - Properties
     * @param {Payload} payload - Payload
     */

    /**
     * An error occurred.
     * @event Channel#error
     * @param {!Error} error - The error object that originates from internally processing or from callbacks
     */

    /**
     * The channel has been closed
     * @event Channel#closed
     * @param {boolean} hadError - Indicates whether or not a channel error occurred and forced the channel to close
     */

    /**
     * The constructor must not be used outside the library, instances are created lazy at a given client
     * @param {!Client} client
     * @param {!Controller} controller
     * @private
     */
    constructor(client, controller) {

        super();

        //noinspection JSUnresolvedVariable
        /**
         * The client instance that contains this channel instance
         * @type {!Client}
         */
        this.client = client;

        /**
         * @type {!Controller}
         * @private
         */
        this._controller = controller;

        /**
         * @const {Map<string, !Exchange>}
         * @private
         */
        this._exchanges = new Map();

        /**
         * @const {Map<string, !Queue>}
         * @private
         */
        this._queues = new Map();

        /**
         * @type {!number}
         * @private
         */
        this._state = STATE.CLOSED;

        /* handle controller events */

        this._controller
            .on('opened', () => {
                this._controller.receive(RETURN, null, (method) => {
                    const ret = /** @type {BasicReturn} */ (method);
                    this.emit('return', ret.replyCode, ret.replyText, ret.exchange, ret.routingKey, ret.properties.data, ret.payload);
                });
            })
            .on('closed', () => {
                if (this._state === STATE.OPENED) {
                    this._state = STATE.CLOSED;
                    this.emit('closed', false);
                } else {
                    this._state = STATE.CLOSED;
                }
            })
            .on('confirms', () => {
                this.emit('confirms');
            })
            .on('error', (error) => this.emit('error', error))
        ;

    }

    id() {
        return this._controller.channelID;
    }

    /**
     * @param {NotifyOfDone=} done
     * @param {NotifyOfFailed=} failed
     */
    open(done, failed) {
        switch (this._state) {
            case STATE.OPENING: {
                if (typeof failed === 'function') failed(ErrMsg(EC.CHANNEL_OPENING));
                return;
            }
            case STATE.OPENED: {
                if (typeof failed === 'function') failed(ErrMsg(EC.CHANNEL_OPENED));
                return;
            }
            case STATE.CLOSING: {
                if (typeof failed === 'function') failed(ErrMsg(EC.CHANNEL_CLOSING));
                return;
            }
            default: {
                this._state = STATE.OPENING;
            }
        }

        this._controller.request(new Model.Channel.Open(), (error, response) => {
            if (response) {
                this._state = STATE.OPENED;
                this._awaitMethodClose();
                if (typeof done === 'function') done();
                this.emit('opened');
            } else {
                if (typeof failed === 'function') failed(error); else if (error) this.emit('error', error);
            }
        });
    }

    /**
     * @param {NotifyOfDone=} done
     * @param {NotifyOfFailed=} failed
     */
    close(done, failed) {
        switch (this._state) {
            case STATE.OPENING: {
                if (typeof failed === 'function') failed(ErrMsg(EC.CHANNEL_OPENING));
                return;
            }
            case STATE.CLOSING: {
                if (typeof failed === 'function') failed(ErrMsg(EC.CHANNEL_CLOSED_CLOSING));
                return;
            }
            case STATE.CLOSED: {
                if (typeof failed === 'function') failed(ErrMsg(EC.CHANNEL_CLOSED));
                return;
            }
            default: {
                this._state = STATE.CLOSING;
            }
        }

        this._controller.request(new Model.Channel.Close(), (error, response) => {
            if (response) {
                if (this._state === STATE.CLOSING) {     // still connected and no close from broker
                    this._controller.cancel(CLOSE, null);
                    this._state = STATE.CLOSED;
                    this.emit('closed', false);
                }
                if (typeof done === 'function') done();
            } else {
                if (typeof failed === 'function') failed(error); else if (error) this.emit('error', error);
            }
        });
    }

    /**
     * @private
     */
    _awaitMethodClose() {
        this._controller.receive(CLOSE, null, (meth) => {
            const close = /** @type {ChannelCloseOk} */(meth);
            this._controller.send(new Model.Channel.CloseOk());
            this._state = STATE.CLOSED;
            if (close.failed) {
                const err = this._controller.reset(close.failed, ErrMsg(EC.CHANNEL_ERROR_AT_METHOD, Method.describeID(close.failed), close.replyCode, close.replyText));
                if (err) this.emit('error', err); // noWait, no callback, hence, emit channel error
                this.emit('closed', true);
            } else if (close.replyCode) {
                this.emit('error', ErrMsg(EC.CHANNEL_ERROR, close.replyCode, close.replyText));
                this.emit('closed', true);
            } else {
                this.emit('closed', false);
            }
        });
    }

    /**
     * @param {NotifyOfDone=} done
     * @param {NotifyOfFailed=} failed
     */
    confirm(done, failed) {
        this._controller.confirm(done, failed);
    }

    /**
     * @callback NotifyOfChannelFlowDone
     * @param {boolean} active
     */

    /**
     * @param {!boolean} active
     * @param {NotifyOfChannelFlowDone=} done
     * @param {NotifyOfFailed=} failed
     */
    flow(active, done, failed) {
        this._controller.request(new Model.Channel.Flow(active), (error, method) => {
            if (method) {
                const response = /** @type {ChannelFlowOk} */(method);
                if (typeof done === 'function') done(response.active);
                this.emit('flow', response.active);
            } else {
                if (typeof failed === 'function') failed(error); else if (error) this.emit('error', error);
            }
        });
    }

    /**
     * @param {!number} prefetchSize
     * @param {!number} prefetchCount
     * @param {!boolean} global
     * @param {NotifyOfDone=} done
     * @param {NotifyOfFailed=} failed
     */
    qos(prefetchSize, prefetchCount, global, done, failed) {
        const request = new Model.Basic.Qos();
        request.prefetchSize = prefetchSize;
        request.prefetchCount = prefetchCount;
        request.global = global;

        this._controller.request(request, (error, response) => {
            if (response) {
                if (typeof done === 'function') done();
            } else {
                if (typeof failed === 'function') failed(error); else if (error) this.emit('error', error);
            }
        });
    }

    /**
     * @param {string=} name
     */
    exchange(name) {
        let instance = this._exchanges.get(name);
        if (!instance) {
            if (typeof name === 'string') {
                instance = new Exchange(this, this._controller, name);
                this._exchanges.set(name, instance);
            } else if (name === undefined || name === null) {
                instance = new Exchange(this, this._controller, '');
                this._exchanges.set('', instance);
            } else {
                throw ErrMsg(EC.APP_ARGS_INVALID_EXCHANGE);
            }
        }
        return instance;
    }

    /**
     * @param {string=} name
     */
    queue(name) {
        let instance = this._queues.get(name);
        if (!instance) {
            if (name === undefined || name === null || name === '') {
                // anonymous, to be declared
                instance = new Queue(this, this._controller, '',
                    (name) => {
                        this._queues.set(name, instance);
                    },
                    (name) => {
                        this._queues.delete(name);
                    }
                );
            } else if (typeof name === 'string') {
                // register a named instance
                instance = new Queue(this, this._controller, name);
                this._queues.set(name, instance);
            } else {
                throw ErrMsg(EC.APP_ARGS_INVALID_QUEUE);
            }
        }
        return instance;
    }

}

module.exports = {
    Channel : Channel
};

