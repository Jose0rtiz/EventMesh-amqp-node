'use strict';

const { Readable, Transform } = require('stream');
const { EC, ErrMsg } = require('../errors');
const { Payload } = require('../serialize/types');
const { Model } = require('../methods/model');
const BasicPublish = Model.Basic.Publish;

/**
 * A stream message for unified stream processing
 * @typedef {Object} UnifiedStreamMessage
 * @property {string|Object} source - Source stream id or a source data if a SourceMapperCallback is used by the stream
 * @property {string|Object} target - Target data if a TargetMapperCallback is used by the stream
 * @property {Buffer|Payload} payload - Message payload
 * @property [boolean} redelivered - The message could have been delivered already, but was not acknowledged
 * @property {NotifyOfDone} done - A callback to use after successful message processing
 * @property {NotifyOfFailed} failed - A callback to use on failed message processing
 */

/**
 * A readable stream for received messages in unified stream format, see also {@link UnifiedStreamMessage}
 * @class IStream
 * @extends {Readable}
 */

/**
 * The IStream has subscribed.
 * @event IStream#subscribed
 */

/**
 * @typedef {Object} OptionsToConsume
 * @property {number} channel - The channel to use.
 * @property {string} exchange - The name of the exchange to bind to.
 * @property {string} routingKey - The routing key to bind to.
 * @property {MapUnifiedStreamMessageSource} mapSource - A source mapper callback
 * @property {boolean} exclusive - Indicates whether or not to subscribe exclusively.
 * @property {boolean} noAcks - Indicates whether or not to subscribe without acknowledges.
 * @property {number} prefetchCount - Limit count of messages in flight, if acknowledges are used.
 * @property {number} prefetchBytes - Limit bytes of messages in flight, if acknowledges are used.
 * @property {number} highWaterMark - The high water mark for the stream (number of messages).
 */

/**
 * @callback MapUnifiedStreamMessageSource
 * @param {string} exchange - The exchange that accepted the message originally
 * @param {string} routingKey - The routing key that was used originally
 * @param {?PayloadProperties} properties - Payload properties the message
 * @returns {Object} - The result can be used as message.source within application processing logic
 */

/**
 * A list of inbound stream definitions, providing the id as key together with options
 * @typedef {Object<string, OptionsToConsume>} UnifiedStreamDeclarationToConsume
 */

/**
 * A list of outbound stream definitions, providing the id as key together with qos and retain flag
 * @typedef {Object<string, OptionsToProduce>} UnifiedStreamDeclarationToProduce
 */

/**
 * @private
 */
class IStream extends Readable {

    /**
     * @param {!string} id
     * @param {!Channel} channel
     * @param {!Controller} controller
     * @param {!OptionsToConsume} options
     */
    constructor(id, channel, controller, options) {

        const exchange = channel.exchange(options.exchange).name();
        const routingKey = typeof options.routingKey === 'string' ? options.routingKey : '';
        const mapSource = typeof options.mapSource === 'function' ? options.mapSource : null;
        const queue = exchange === '' ? channel.queue(options.routingKey) : channel.queue();
        const noAck = typeof options.noAck === 'boolean' ? options.noAck : true;
        const exclusive = exchange === '' ? (options.exclusive ? options.exclusive : false) : true;
        const prefetchCount = !noAck && options.prefetchCount ? parseInt(options.prefetchCount) : 0;
        const prefetchBytes = !noAck && options.prefetchBytes ? parseInt(options.prefetchBytes) : 0;
        const highWaterMark = options.highWaterMark ? Math.max(parseInt(options.highWaterMark), 100) : 1000;

        let active = false;
        let online = false;

        /**
         *
         */
        super({
            highWaterMark : noAck ? highWaterMark : Math.max(highWaterMark, prefetchCount + 1),
            objectMode    : true,
            read          : (size) => {
                if (!active) {
                    active = true;
                    if (online && noAck) {        // acknowledges are the better flow control
                        channel.client.resume();
                    }
                }
            }
        });

        let count = 0;

        /**
         * create receive callback
         * @private
         */
        const receive = noAck ?
            /** @type {ReceiveCallbackNoAck} */ (
                (exchange, routingKey, redelivered, properties, payload) => {
                    const item = {
                        source      : mapSource ? mapSource(exchange, routingKey, properties) : id,
                        payload     : payload,
                        redelivered : redelivered,
                        done        : nop,
                        failed      : (error) => { this.emit('error', error); }
                    };

                    if (!this.push(item) && active) {
                        active = false;
                        channel.client.pause();
                    }
                }
            ):
            /** @type {ReceiveCallbackAck} */ (
                (exchange, routingKey, redelivered, properties, payload, acknowledge, reject) => {
                    const item = {
                        source      : mapSource ? mapSource(exchange, routingKey, properties) : id,
                        payload     : payload,
                        redelivered : redelivered,
                        done        : () => { acknowledge(false); },
                        failed      : (error) => { this.emit('error', error ? error : EC.APP_STREAM_RECEIVE_UNKNOWN_ERROR); reject(true); }
                    };

                    if (!this.push(item) && active) {
                        active = false;
                        channel.client.pause();
                    }
                }
            );

        /**
         * consume from queue
         */
        const consume = () => {
            if (prefetchCount || prefetchBytes) {
                channel.qos(prefetchBytes, prefetchCount, false);
            }
            queue.consume(false, noAck, exclusive, null, receive,
                () => {
                    this.emit('subscribed');
                },
                (error) => {
                    this.emit('error', error);
                });
        };

        if (exchange === '') {
            channel.on('opened', () => {
                online = true;
                consume();
            });
        } else {
            channel.on('opened', () => {
                online = true;
                queue.declare(false, false, true, true, null,
                    (messageCount, consumerCount) => {
                        queue.bind(exchange, routingKey, null,
                            () => {
                                consume();
                            },
                            (error) => {
                                this.emit('error', error);
                            }
                        );
                    },
                    (error) => {
                        this.emit('error', error);
                    }
                );
            });
        }
        channel.on('closed', () => {
            online = false;
        });
    }

}

/**
 * A writable stream to publish messages in unified stream format, see also {@link UnifiedStreamMessage}
 * @class OStream
 * @extends {Writable}
 */

/**
 * The OStream is ready for use.
 * @event OStream#ready
 * @param {number} qos - The quality of service that will be used
 */

/**
 * @typedef {Object} OptionsToProduce
 * @property {number} channel - The channel to use.
 * @property {string} exchange - The name of the exchange at which to publish.
 * @property {string} routingKey - The rounting key to use at the exchange.
 * @property {MapUnifiedStreamMessageTarget} mapTarget - A target mapper callback
 * @property {boolean} mandatory - Indicates whether or not to add the mandatory flag.
 * @property {boolean} immediate - Indicates whether or not to add the immediate flag.
 * @property {PayloadProperties} properties - Payload properties to use for each message.
 * @property {boolean} confirms - The channel shall run in confirm mode.
 * @property {number} highWaterMark - The high water mark for the stream (number of messages).
 */

/**
 * @typedef {Object} PublishParameters
 * @property {string} exchange - The exchange to publish the message
 * @property {string} routingKey - The routing key to publish the message
 * @property {PayloadProperties} properties - Payload properties to assign to the message
 */

/**
 * @callback MapUnifiedStreamMessageTarget
 * @param {Object} target - Target attribute of a message, provided by application logic
 * @returns {PublishParameters} - dynamically determined settings to publish the message
 */

/**
 * @private
 */
class OStream extends Transform {

    /**
     * @param {!string} id
     * @param {!Channel} channel
     * @param {!Controller} controller
     * @param {!OptionsToProduce} options
     */
    constructor(id, channel, controller, options) {

        const channelID = controller.channelID;
        const defaultTarget = {
            exchange   : typeof options.exchange === 'string' ? channel.exchange(options.exchange).name() : null,
            routingKey : typeof options.routingKey === 'string' ? options.routingKey : null,
            properties : typeof options.properties === 'object' ? options.properties : null
        };
        const mapTarget = typeof options.mapTarget === 'function' ? options.mapTarget : null;
        const mandatory = typeof options.mandatory === 'boolean' ? options.mandatory : false;
        const immediate = typeof options.immediate === 'boolean' ? options.immediate : false;
        const confirms = typeof options.confirms === 'boolean' ? options.confirms : false;
        const highWaterMark = options.highWaterMark ? Math.max(parseInt(options.highWaterMark), 100) : 1000;
        const defaultNotifyOfFailed = (error) => { this.emit('error', error); };

        super({
            highWaterMark: highWaterMark,
            decodeStrings: false,
            allowHalfOpen: false,
            readableObjectMode: true,
            writableObjectMode: true,

            /**
             * @param {!UnifiedStreamMessage} message
             * @param {string} encoding
             * @param {function(Error=, BasicPublish=)} callback
             * @private
             */
            transform : (message, encoding, callback) => {
                try {
                    const publish = new BasicPublish();
                    publish.controller = controller;
                    publish.mandatory = mandatory;
                    publish.immediate = immediate;
                    publish.channelID = channelID;
                    publish.done = typeof message.done === 'function' ? message.done : nop;
                    publish.failed = typeof message.failed === 'function' ? message.failed : defaultNotifyOfFailed;

                    const target = mapTarget ? mapTarget(message.target) : null;
                    if (target) {
                        publish.exchange = typeof target.exchange === 'string' ? target.exchange : null;
                        publish.routingKey = typeof target.routingKey === 'string' ? target.routingKey : null;
                        publish.properties.data = typeof target.properties === 'object' ? target.properties : null;
                    } else {
                        publish.exchange = defaultTarget.exchange;
                        publish.routingKey = defaultTarget.routingKey;
                        publish.properties.data = defaultTarget.properties;
                    }

                    if (message.payload) {
                        const payload = message.payload;
                        if (Buffer.isBuffer(payload)) {
                            publish.payload.chunks.push(payload);
                        } else if (Array.isArray(payload) && payload.every(item => Buffer.isBuffer(item))) {
                            publish.payload.chunks = payload;
                        } else if (payload && typeof payload === 'object' && Array.isArray(payload.chunks) && payload.chunks.every(item => Buffer.isBuffer(item))) {
                            publish.payload = payload;
                        } else {
                            callback(ErrMsg(EC.APP_ARGS_INVALID_PAYLOAD_TO_PUBLISH));
                            return true;
                        }
                    }

                    callback(null, publish);
                } catch (error) {
                    callback(error);
                }
            }
        });

        let online = false;
        let target = null;

        const start = () => {
            if (online && target) {
                this.pipe(target, {end: false});
                this.emit('ready');
            }
        };

        channel
            .on('opened', () => {
                online = true;
                if (confirms) {
                    controller.confirm();
                }
                if (target) {
                    process.nextTick(start);
                }
            })
            .on('closed', () => {
                if (target) {
                    this.unpipe(target);
                }
                online = false;
            });

        controller
            .on('opened', (ostream) => {
                target = ostream;
                if (online) {
                    process.nextTick(start);
                }
            })
            .on('closed', () => {
                if (online) {
                    this.unpipe(target);
                }
                target = null;
            });

    }

}

/**
 * @param {*=} result
 * @return {*}
 * @private
 */
function nop(result) { return result; }

module.exports = {
    IStream : IStream,
    OStream : OStream
};

