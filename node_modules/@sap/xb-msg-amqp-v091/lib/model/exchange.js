'use strict';

const { EC, ErrMsg } = require('../errors');
const { Model } = require('../methods/model');
const BasicPublish = Model.Basic.Publish;

/**
 * The exchange proxy class.
 */
class Exchange {

    /**
     * The constructor must not be used outside the library, instances are created lazy at a given channel
     * @param {!Channel} channel
     * @param {!Controller} controller
     * @param {!string} name
     * @ignore
     */
    constructor(channel, controller, name) {

        /**
         * The channel instance that contains this exchange instance
         * @type {!Channel}
         */
        this.channel = channel;

        //noinspection JSUnusedGlobalSymbols
        /**
         * @type {!boolean}
         */
        this.static = name.startsWith('amq.');

        /**
         * @type {!Controller}
         * @private
         */
        this._controller = controller;

        /**
         * @type {string}
         * @private
         */
        this._name = name;

        /**
         * @type {!NotifyOfFailed}
         * @private
         */
        this._defaultNotifyOfFailed = (error) => this.channel.emit('error', error);

    }

    /**
     * @return {!string}
     */
    name() {
        return this._name;
    }

    /**
     * @param {!string} type
     * @param {!boolean} passive
     * @param {!boolean} durable
     * @param {?FieldTable} args
     * @param {NotifyOfDone=} done
     * @param {NotifyOfFailed=} failed
     */
    declare(type, passive, durable, args, done, failed) {
        const request = new Model.Exchange.Declare();
        request.exchange = this._name;
        request.type = type;
        request.passive = passive;
        request.durable = durable;
        request.noWait = !(typeof done === 'function' && typeof failed === 'function');
        request.args = args ? args : request.args;

        if (request.noWait) {
            this._controller.send(request);
        } else {
            this._controller.request(request, (error, response) => {
                if (response) {
                    done();
                } else {
                    failed(error);
                }
            });
        }
    }

    /**
     * @param {!boolean} ifUnused
     * @param {NotifyOfDone=} done
     * @param {NotifyOfFailed=} failed
     */
    remove(ifUnused, done, failed) {
        const request = new Model.Exchange.Delete();
        request.exchange = this._name;
        request.ifUnused = ifUnused;
        request.noWait = !(typeof done === 'function' && typeof failed === 'function');

        if (request.noWait) {
            this._controller.send(request);
        } else {
            this._controller.request(request, (error, response) => {
                if (response) {
                    done();
                } else {
                    failed(error);
                }
            });
        }
    }

    /**
     * @param {!string} source
     * @param {!string} routingKey
     * @param {?FieldTable} args
     * @param {NotifyOfDone=} done
     * @param {NotifyOfFailed=} failed
     */
    bind(source, routingKey, args, done, failed) {
        const request = new Model.Exchange.Bind();
        request.exchange = this._name;
        request.source = source;
        request.routingKey = routingKey;
        request.noWait = !(typeof done === 'function' && typeof failed === 'function');
        request.args = args ? args : request.args;

        if (request.noWait) {
            this._controller.send(request);
        } else {
            this._controller.request(request, (error, response) => {
                if (response) {
                    done();
                } else {
                    failed(error);
                }
            });
        }
    }

    /**
     * @param {!string} source
     * @param {!string} routingKey
     * @param {?FieldTable} args
     * @param {NotifyOfDone=} done
     * @param {NotifyOfFailed=} failed
     */
    unbind(source, routingKey, args, done, failed) {
        const request = new Model.Exchange.Unbind();
        request.exchange = this._name;
        request.source = source;
        request.routingKey = routingKey;
        request.noWait = !(typeof done === 'function' && typeof failed === 'function');
        request.args = args ? args : request.args;

        if (request.noWait) {
            this._controller.send(request);
        } else {
            this._controller.request(request, (error, response) => {
                if (response) {
                    done();
                } else {
                    failed(error);
                }
            });
        }
    }

    /**
     * @callback NotifyOfFailedPublish
     * @param {!Error} error
     * @param {!boolean} repeatable
     */

    /**
     * @param {!string} routingKey
     * @param {!boolean} mandatory
     * @param {!boolean} immediate
     * @param {?PayloadProperties} properties
     * @param {Buffer|Array<Buffer>|Payload} payload
     * @param {NotifyOfDone=} done
     * @param {NotifyOfFailedPublish=} failed
     * @return {!boolean}
     */
    publish(routingKey, mandatory, immediate, properties, payload, done, failed) {
        const publish = new BasicPublish();
        publish.controller = this._controller;
        publish.done = typeof done === 'function' ? done : nop;
        publish.failed = typeof failed === 'function' ? failed : this._defaultNotifyOfFailed;

        publish.exchange = this._name;
        publish.routingKey = routingKey;
        publish.mandatory = mandatory;
        publish.immediate = immediate;
        publish.properties.data = properties;

        if (payload) {
            if (Buffer.isBuffer(payload)) {
                publish.payload.chunks.push(payload);
            } else if (Array.isArray(payload) && payload.every(item => Buffer.isBuffer(item))) {
                publish.payload.chunks = payload;
            } else if (payload && typeof payload === 'object' && Array.isArray(payload.chunks) && payload.chunks.every(item => Buffer.isBuffer(item))) {
                publish.payload = payload;
            } else {
                publish.failed(ErrMsg(EC.APP_ARGS_INVALID_PAYLOAD_TO_PUBLISH));
                return true;
            }
        }

        return this._controller.send(publish);
    }

}

/**
 * @param {*=} result
 * @return {*}
 * @private
 */
function nop(result) { return result; }

module.exports = {
    Exchange : Exchange
};

