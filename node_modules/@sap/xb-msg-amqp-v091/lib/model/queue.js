'use strict';

const { EC, ErrMsg } = require('../errors');
const { Payload } = require('../serialize/types');
const { Model } = require('../methods/model');

const constants = require('../serialize/constants');
const BASIC_GET_EMPTY = constants.METHOD.BASIC.GET_EMPTY;
const BASIC_DELIVER = constants.METHOD.BASIC.DELIVER;

/**
 * The queue proxy class.
 */
class Queue {

    /**
     * The constructor must not be used outside the library, instances are created lazy at a given channel
     * @param {!Channel} channel
     * @param {!Controller} controller
     * @param {!string} name
     * @param {function(!string)=} register
     * @param {function(!string)=} release
     * @ignore
     */
    constructor(channel, controller, name, register, release) {

        /**
         * The channel instance that contains this queue instance
         * @type {!Channel}
         */
        this.channel = channel;

        /**
         * @type {boolean}
         */
        this.autoDelete = undefined;

        /**
         * @type {boolean}
         */
        this.autoName = (name.length === 0);

        /**
         * @type {!Controller}
         * @private
         */
        this._controller = controller;

        /**
         * @type {!string}
         * @private
         */
        this._name = name;

        /**
         * @const {function(!string)}
         * @private
         */
        this._register = register;

        /**
         * @const {function(!string)}
         * @private
         */
        this._release = release;

    }

    //noinspection JSUnusedGlobalSymbols
    /**
     * @return {?string}
     */
    name() {
        return this._name;
    }

    /**
     * @callback NotifyOfQueueDeclareDone
     * @param {number} messageCount
     * @param {number} consumerCount
     */

    /**
     * @param {!boolean} passive
     * @param {!boolean} durable
     * @param {!boolean} exclusive
     * @param {!boolean} autoDelete
     * @param {?FieldTable} args
     * @param {NotifyOfQueueDeclareDone=} done
     * @param {NotifyOfFailed=} failed
     */
    declare(passive, durable, exclusive, autoDelete, args, done, failed) {
        const request = new Model.Queue.Declare();
        request.queue = this._name;
        request.passive = passive;
        request.durable = durable;
        request.exclusive = exclusive;
        request.autoDelete = autoDelete;
        request.noWait = !(this._name === '' || typeof done === 'function' || typeof failed === 'function');
        request.args = args ? args : request.args;

        if (request.noWait) {
            this._controller.send(request);
        } else {
            this._controller.request(request, (err, res) => {
                if (res) {
                    const response = /** @type {QueueDeclareOk} */ (res);
                    if (!this._name) {
                        this._name = response.queue;
                        this._register(this._name);
                        if (autoDelete) {
                            this._controller.once('closed', () => {
                                this._release(this._name);
                                this._name = null;
                            });
                        }
                    }
                    this.autoDelete = autoDelete;
                    if (typeof done === 'function') done(response.messageCount, response.consumerCount);
                } else {
                    if (typeof failed === 'function') failed(err); else if (err) this.channel.emit('error', err);
                }
            });
        }
    }

    /**
     * @param {!string} exchange
     * @param {!string} routingKey
     * @param {?FieldTable} args
     * @param {NotifyOfDone=} done
     * @param {NotifyOfFailed=} failed
     */
    bind(exchange, routingKey, args, done, failed) {
        const request = new Model.Queue.Bind();
        request.queue = this._name;
        request.exchange = exchange;
        request.routingKey = routingKey;
        request.args = args;
        request.noWait = !(typeof done === 'function' && typeof failed === 'function');

        if (request.noWait) {
            this._controller.send(request);
        } else {
            this._controller.request(request, (err, response) => {
                if (response) {
                    done();
                } else {
                    failed(err);
                }
            });
        }
    }

    /**
     * @param {!string} exchange
     * @param {!string} routingKey
     * @param {?FieldTable} args
     * @param {NotifyOfDone=} done
     * @param {NotifyOfFailed=} failed
     */
    unbind(exchange, routingKey, args, done, failed) {
        const request = new Model.Queue.Unbind();
        request.queue = this._name;
        request.exchange = exchange;
        request.routingKey = routingKey;
        request.args = args;

        this._controller.request(request, (err, response) => {
            if (response) {
                done();
            } else {
                failed(err);
            }
        });
    }

    /**
     * @callback NotifyOfQueuePurgeDone
     * @param {number} messageCount
     */

    /**
     * @param {NotifyOfQueuePurgeDone=} done
     * @param {NotifyOfFailed=} failed
     */
    purge(done, failed) {
        const request = new Model.Queue.Purge();
        request.queue = this._name;
        request.noWait = !(typeof done === 'function' && typeof failed === 'function');

        if (request.noWait) {
            this._controller.send(request);
        } else {
            this._controller.request(request, (err, res) => {
                if (res) {
                    const response = /** @type {QueuePurgeOk} */ (res);
                    done(response.messageCount);
                } else {
                    failed(err);
                }
            });
        }
    }

    /**
     * @callback NotifyOfQueueRemoveDone
     * @param {number} messageCount
     */

    /**
     * @param {!boolean} ifUnused
     * @param {!boolean} ifEmpty
     * @param {NotifyOfQueueRemoveDone=} done
     * @param {NotifyOfFailed=} failed
     */
    remove(ifUnused, ifEmpty, done, failed) {
        const request = new Model.Queue.Delete();
        request.queue = this._name;
        request.ifUnused = ifUnused;
        request.ifEmpty = ifEmpty;
        request.noWait = !(this.autoName || typeof done === 'function' || typeof failed === 'function');

        if (request.noWait) {
            this._controller.send(request);
        } else {
            this._controller.request(request, (err, res) => {
                if (res) {
                    const response = /** @type {QueueDeleteOk} */ (res);
                    if (this.autoName) {
                        this._release(this._name);
                        this._name = null;
                    }
                    if (typeof done === 'function') done(response.messageCount);
                } else {
                    if (typeof failed === 'function') failed(err); else if (err) this.channel.emit('error', err);
                }
            });
        }
    }

    /**
     * @callback NotifyOfQueueGetOkAcknowledge
     */

    /**
     * @callback NotifyOfQueueGetOkReject
     * @param {boolean} requeue
     */

    /**
     * @callback NotifyOfQueueGetOkNoAck
     * @param {string} exchange
     * @param {string} routingKey
     * @param {boolean} redelivered
     * @param {?PayloadProperties} properties
     * @param {?Payload} payload
     */

    /**
     * @callback NotifyOfQueueGetOkAck
     * @param {string} exchange
     * @param {string} routingKey
     * @param {boolean} redelivered
     * @param {?PayloadProperties} properties
     * @param {?Payload} payload
     * @param {NotifyOfQueueGetOkAcknowledge=} acknowledge
     * @param {NotifyOfQueueGetOkReject=} reject
     */

    /**
     * @callback NotifyOfQueueGetEmpty
     */

    /**
     * @param {!boolean} noAck
     * @param {!(NotifyOfQueueGetOkAck | NotifyOfQueueGetOkNoAck)} ok
     * @param {!NotifyOfQueueGetEmpty} empty
     * @param {!NotifyOfFailed} failed
     */
    get(noAck, ok, empty, failed) {
        const request = new Model.Basic.Get();
        request.queue = this._name;
        request.noAck = noAck;
        this._controller.request(request, (err, res) => {
            if(!res) {
                failed(err);
            } else if (res.classMethodID === BASIC_GET_EMPTY) {
                empty();
            } else if (noAck) {
                const response = /** @type {BasicGetOk} */ (res);
                ok(response.exchange, response.routingKey, response.redelivered, response.properties.data, response.payload);
            } else {
                const response = /** @type {BasicGetOk} */ (res);
                ok(response.exchange, response.routingKey, response.redelivered, response.properties.data, response.payload,
                    /* acknowledge */
                    () => {
                        const basicAck = new Model.Basic.Ack();
                        basicAck.deliveryTag = response.deliveryTag;
                        basicAck.multiple = false;
                        this._controller.send(basicAck);
                    },
                    /* reject */
                    (requeue) => {
                        const basicReject = new Model.Basic.Reject();
                        basicReject.deliveryTag = response.deliveryTag;
                        basicReject.requeue = requeue;
                        this._controller.send(basicReject);
                    }
                );
            }
        });
    }

    /**
     * @callback NotifyOfAcknowledge
     * @param {boolean} multiple
     */

    /**
     * @callback NotifyOfReject
     * @param {boolean} requeue
     */

    /**
     * @callback ReceiveCallbackAck
     * @param {string} exchange
     * @param {string} routingKey
     * @param {boolean} redelivered
     * @param {?PayloadProperties} properties
     * @param {?Payload} payload
     * @param {NotifyOfAcknowledge} acknowledge
     * @param {NotifyOfReject} reject
     */

    /**
     * @callback ReceiveCallbackNoAck
     * @param {string} exchange
     * @param {string} routingKey
     * @param {boolean} redelivered
     * @param {?PayloadProperties} properties
     * @param {?Payload} payload
     */

    /**
     * @param {!boolean} noLocal not supported by RABBIT, would not consume, what was published on the same connection
     * @param {!boolean} noAck
     * @param {!boolean} exclusive
     * @param {?FieldTable} args
     * @param {!(ReceiveCallbackAck | ReceiveCallbackNoAck)} receive
     * @param {NotifyOfDone=} done
     * @param {NotifyOfFailed=} failed
     */
    consume(noLocal, noAck, exclusive, args, receive, done, failed) {

        const request = new Model.Basic.Consume();
        request.queue = this._name;
        request.consumerTag = this._name;
        request.noLocal = noLocal;
        request.noAck = noAck;
        request.exclusive = exclusive;
        request.noWait = false;
        request.args = args ? args : request.args;

        if (request.noAck) {
            this._controller.receive(BASIC_DELIVER, request.consumerTag, (dlv) => {
                const deliver = /** @type {BasicDeliver} */ (dlv);
                receive(deliver.exchange, deliver.routingKey, deliver.redelivered, deliver.properties.data, deliver.payload);
            });
        } else {
            this._controller.receive(BASIC_DELIVER, request.consumerTag, (dlv) => {
                const deliver = /** @type {BasicDeliver} */ (dlv);
                const tag = deliver.deliveryTag;
                receive(deliver.exchange, deliver.routingKey, deliver.redelivered, deliver.properties.data, deliver.payload,
                    /* acknowledge */
                    (multiple) => {
                        const basicAck = new Model.Basic.Ack();
                        basicAck.deliveryTag = tag;
                        basicAck.multiple = multiple;
                        this._controller.send(basicAck);
                    },
                    /* reject */
                    (requeue) => {
                        const basicReject = new Model.Basic.Reject();
                        basicReject.deliveryTag = tag;
                        basicReject.requeue = requeue;
                        this._controller.send(basicReject);
                    }
                );
            });
        }

        this._controller.request(request, (err, response) => {
            if (response) {
                if (typeof done === 'function') done();
            } else if (err) {
                this._controller.cancel(BASIC_DELIVER, request.consumerTag);
                if (typeof failed === 'function') failed(err); else this.channel.emit('error', err);
            } else {
                if (typeof failed === 'function') failed(null);
            }
        });

    }

    /**
     * @param {NotifyOfDone=} done
     * @param {NotifyOfFailed=} failed
     */
    cancel(done, failed) {
        const request = new Model.Basic.Cancel();
        request.consumerTag = this._name;
        request.noWait = false;
        this._controller.request(request, (err, response) => {
            if (response) {
                this._controller.cancel(BASIC_DELIVER, request.consumerTag);
                if (typeof done === 'function') done();
            } else {
                if (typeof failed === 'function') failed(err); else if (err) this.channel.emit('error', err);
            }
        });
    }

}

module.exports = {
    Queue : Queue
};

