'use strict';

const EventEmitter = require('events');
const Writable = require('stream').Writable;
const { EC, ErrMsg } = require('../errors');
const { Method } = require('../serialize/types');
const { Model } = require('../methods/model');

const AMQP = require('../serialize/constants');

/**
 * @private
 */
class ConfirmController {

    /**
     *
     */
    constructor() {

        /**
         * @const {Map<number, {done: function(), failed : function(!Error)}>}
         * @private
         */
        this._pending = new Map();

        /**
         * @type {number}
         * @private
         */
        this._published = 0;

        /**
         * @type {number}
         * @private
         */
        this._confirmed = 0;

        /**
         * @const {!Error}
         * @private
         */
        this._nackError = ErrMsg(EC.CONTROLLER_PUBLISH_NOT_CONFIRMED);

    }

    /**
     *
     */
    freeUnconfirmedPublish() {
        const error = ErrMsg(EC.CONTROLLER_CONFIRM_CANCEL_ON_CLOSE);
        for (const item of this._pending.values()) {
            item.failed(error, true);
        }
        this._pending.clear();
    }

    /**
     * @param {!BasicPublish} publish
     */
    onOutboundBasicPublish(publish) {
        this._pending.set(++this._published, {
            done   : publish.done,
            failed : publish.failed
        });
    }

    /**
     * @param {!BasicAck} method
     */
    onInboundBasicAck(method) {
        if (method.multiple) {
            while(this._confirmed < method.deliveryTag) {              // all up to and including ack index
                const item = this._pending.get(++this._confirmed);
                if(!item) continue;
                this._pending.delete(this._confirmed);
                item.done();
            }
        } else if (method.deliveryTag - this._confirmed === 1) {       // just the next item, update offset
            const item = this._pending.get(++this._confirmed);
            if(!item) return;
            this._pending.delete(this._confirmed);
            item.done();
        } else {                                                       // any pending, but not the next
            const item = this._pending.get(method.deliveryTag);
            if(!item) return;
            this._pending.delete(method.deliveryTag);
            item.done();
        }
    }

    /**
     * @param {!BasicNack} method
     */
    onInboundBasicNack(method) {
        if (method.multiple) {
            while(this._confirmed < method.deliveryTag) {              // all up to and including ack index
                const item = this._pending.get(++this._confirmed);
                if(!item) continue;
                this._pending.delete(this._confirmed);
                item.failed(this._nackError, false);
            }
        } else if (method.deliveryTag - this._confirmed === 1) {       // just the next item, update offset
            const item = this._pending.get(++this._confirmed);
            if(!item) return;
            this._pending.delete(this._confirmed);
            item.failed(this._nackError, false);
        } else {                                                       // any pending, but not the next
            const item = this._pending.get(method.deliveryTag);
            if(!item) return;
            this._pending.delete(method.deliveryTag);
            item.failed(this._nackError, false);
        }
    }

}

/**
 * @private
 */
class Controller extends EventEmitter {

    /**
     * @param {!Method} method
     * @private
     */
    static _sendDisabled(method) {
        throw ErrMsg(EC.CONTROLLER_SENDING);
    }

    static _autoConfirm(publish) {
        publish.done();
    }

    /**
     * @param {!Behavior} behavior
     * @param {!number} channelID
     */
    constructor(behavior, channelID) {

        super();

        this.setMaxListeners(20);

        /**
         * @const {!Behavior}
         */
        this.behavior = behavior;

        /**
         * @const {!number}
         */
        this.channelID = channelID;

        /**
         * @const {!Map}
         * @private
         */
        this._requested = new Map();

        /**
         * @const {!Map}
         * @private
         */
        this._receiving = new Map();

        /**
         * @type {function(!Method) : !boolean}
         * @private
         */
        this._sendMethod = Controller._sendDisabled;

        /**
         * @type {function(!BasicPublish)}
         */
        this.onPublishSerialized = Controller._autoConfirm;

        /**
         * @type {?ConfirmController}
         * @private
         */
        this._confirms = null;

    }

    /**
     * @param {!Writable} ostream
     */
    start(ostream) {
        // noinspection JSUnresolvedFunction
        this._sendMethod = (frame) => ostream.write(frame);
        this.emit('opened', ostream);
    }

    /**
     * @param {?number} requestID
     * @param {?Error} responseError
     * @return {?Error}
     */
    reset(requestID, responseError) {
        let dispatched = false;
        this._requested.forEach((rpc, classMethodID) => {
            if (rpc.await) {
                if (classMethodID === requestID) {
                    rpc.await.callback(responseError);
                    dispatched = true;
                } else {
                    rpc.await.callback(null, null);
                }
                rpc.queue.forEach((item) => {
                    item.callback(null, null);
                });
            }
        });

        if (this._confirms !== null) {
            this._confirms.freeUnconfirmedPublish();
            this._confirms = null;
        }
        this.onPublishSerialized = Controller._autoConfirm;

        this._requested.clear();
        this._receiving.clear();

        this.emit('closed');
        return dispatched ? null : responseError;
    }

    /**
     *
     */
    close() {
        this._sendMethod = Controller._sendDisabled;
        this.reset(null, null);
    }

    /**
     * Switch channel into confirm mode
     * @param {NotifyOfDone=} done
     * @param {NotifyOfFailed=} failed
     */
    confirm(done, failed) {
        if (this._confirms !== null) return;
        this._confirms = new ConfirmController();
        this.onPublishSerialized = (publish) => this._confirms.onOutboundBasicPublish(publish);
        this.receive(AMQP.METHOD.BASIC.ACK, null, (ack) => this._confirms.onInboundBasicAck(/**@type{BasicAck}*/(ack)));
        this.receive(AMQP.METHOD.BASIC.NACK, null, (nack) => this._confirms.onInboundBasicNack(/**@type{BasicNack}*/(nack)));

        const request = new Model.Confirm.Select();
        request.noWait = (typeof done !== 'function' && typeof failed !== 'function');

        if (request.noWait) {
            this.send(request);
            this.emit('confirms');
        } else {
            this.request(request, (err, response) => {
                if (response) {
                    if (typeof done === 'function') done();
                } else {
                    this.cancel(AMQP.METHOD.BASIC.NACK, null);
                    this.cancel(AMQP.METHOD.BASIC.ACK, null);
                    this._confirms = null;
                    this.onPublishSerialized = Controller._autoConfirm;
                    if (err) {
                        this.emit('confirms');
                        if (typeof done === 'function') failed(err);
                    } else {
                        if (typeof failed === 'function') failed(null);
                    }
                }
            });
        }
    }

    /**
     * @param {!Method} method
     * @param {!function(!Error, !Method)} callback
     * @returns {boolean}
     */
    request(method, callback) {
        method.channelID = this.channelID;
        let rpc = this._requested.get(method.classMethodID);
        if (!rpc) {
            rpc = {await: {method, callback}, queue: []};
            this._requested.set(method.classMethodID, rpc);
        } else if (rpc.await) {
            rpc.queue.push({method, callback});
            return true;
        } else {
            rpc.await = {method, callback};
        }
        try {
            return this._sendMethod(method);
        } catch (e) {
            rpc.await = null;
            throw e;
        }
    }

    /**
     * @param {!Method} method
     * @returns {boolean}
     */
    send(method) {
        method.channelID = this.channelID;
        return this._sendMethod(method);
    }

    /**
     * @param {!number} classMethodID
     * @param {?string} objectKey
     * @param {!function(!Method)} callback
     */
    receive(classMethodID, objectKey, callback) {
        let registrations = this._receiving.get(classMethodID);
        if (!registrations) {
            registrations = {/**@type{?function(!Method)}*/noKey: null, byKey: new Map()};
            this._receiving.set(classMethodID, registrations);
        }
        if (objectKey) {
            if (registrations.byKey.has(objectKey)) {
                throw ErrMsg(EC.CONTROLLER_REGISTRATION_DUPLICATE, Method.describeID(classMethodID));
            } else {
                registrations.byKey.set(objectKey, callback);
            }
        } else {
            if (registrations.noKey) {
                throw ErrMsg(EC.CONTROLLER_REGISTRATION_DUPLICATE, Method.describeID(classMethodID));
            } else {
                registrations.noKey = callback;
            }
        }
    }

    /**
     * @param {!number} classMethodID
     * @param {?string} objectKey
     */
    cancel(classMethodID, objectKey) {
        const registrations = this._receiving.get(classMethodID);
        if (!registrations) {
            throw ErrMsg(EC.CONTROLLER_REGISTRATION_NOT_FOUND, Method.describeID(classMethodID));
        }
        if (objectKey === null) {
            if (registrations.noKey === null) {
                throw ErrMsg(EC.CONTROLLER_REGISTRATION_NOT_FOUND_KEY, Method.describeID(classMethodID), 'null');
            } else {
                registrations.noKey = null;
            }
        } else {
            if (!registrations.byKey.delete(objectKey)) {
                throw ErrMsg(EC.CONTROLLER_REGISTRATION_NOT_FOUND_KEY, Method.describeID(classMethodID), objectKey);
            }
        }
    }

    /**
     * @param {!Method} method
     */
    dispatch(method) {
        if (this._sendMethod === Controller._sendDisabled) { // channel was closed, ignore further inbound methods
            return;
        }
        if (method.requestClassMethodID) {
            const item = this._requested.get(method.requestClassMethodID);
            if (!item || !item.await) {
                throw ErrMsg(EC.CONTROLLER_METHOD_UNEXPECTED, Method.describeID(method.classMethodID));
            }
            const callback = item.await.callback;
            if (item.queue.length) {
                item.await = item.queue.shift();
                this._sendMethod(item.await.method);
            } else {
                item.await = null;
            }
            callback(null, method);
        } else {
            const registrations = this._receiving.get(method.classMethodID);
            if (!registrations) {
                throw ErrMsg(EC.CONTROLLER_METHOD_UNEXPECTED, Method.describeID(method.classMethodID));
            }
            const objectKey = method.objectKey();
            const callback = objectKey ? registrations.byKey.get(objectKey) : registrations.noKey;
            if (!callback) {
                throw ErrMsg(EC.CONTROLLER_METHOD_UNEXPECTED_KEY, Method.describeID(method.classMethodID), objectKey);
            }
            callback(method);
        }
    }

}

module.exports = {
    Controller : Controller,
    ConfirmController : ConfirmController
};

