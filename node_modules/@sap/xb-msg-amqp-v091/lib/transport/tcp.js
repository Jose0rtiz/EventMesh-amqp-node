'use strict';

const EventEmitter = require('events');
const tls = require('tls');
const net = require('net');

const { Writable, Transform } = require('stream');
const { Encoder } = require('../serialize/encoder');
const { Decoder } = require('../serialize/decoder');

/**
 * @typedef {Object} ConnectOptions
 * @property {ProtocolSettings} amqp - Protocol specific settings
 * @property {StreamParameters} tune - Fine tuning
 * @private
 */

/**
 * @callback NotifyOfConnect
 * @param {!TcpConnection} connection
 * @private
 */

/**
 * @private
 */
class TcpReader extends Transform {

    /**
     * @param {!StreamParameters} options
     * @param {!Behavior} behavior
     * @param {!MethodFactory} factory
     */
    constructor(options, behavior, factory) {

        super({
            decodeStrings: false,
            allowHalfOpen: false,
            highWaterMark: undefined,
            writableObjectMode: false,
            writableHighWaterMark: options.istreamHighWaterBytes,  // as of nodeJS 8, fixed in Aug 2017
            readableObjectMode: true,
            readableHighWaterMark: options.istreamHighWaterFrames, // as of nodeJS 8, fixed in Aug 2017
        });

        /**
         * @type {Decoder}
         */
        this.decoder = new Decoder(behavior, factory,
            (frame) => this.push(frame),
            () => this.emit('heartbeat')
        );

    }

    // noinspection JSUnusedGlobalSymbols
    /**
     * @param {!Buffer} chunk
     * @param {!string} encoding
     * @param {!function(Error=, Method=)} callback
     * @override
     */
    _transform(chunk, encoding, callback) {
        try {
            this.decoder.push(chunk);
            callback();
        } catch (e) {
            this.decoder.stop();
            callback(e);
        }
    }

}

/**
 * @private
 */
class TcpWriter extends Writable {

    /**
     * @param {!StreamParameters} options
     * @param {!Behavior} behavior
     * @param {!Socket} socket
     */
    constructor(options, behavior, socket) {

        super({
            highWaterMark: options.ostreamHighWaterFrames,
            decodeStrings: false,
            objectMode: true,
        });

        /**
         * @type {number}
         */
        this.statChunkDefAllocCount = 0;

        /**
         * @type {number}
         */
        this.statChunkBigAllocCount = 0;

        /**
         * @type {number}
         */
        this.statChunkRecycledCount = 0;

        /**
         * @type {number}
         * @private
         */
        this._chunkDefaultSize = options.ostreamChunkDefaultSize;

        /**
         * @type {number}
         * @private
         */
        this._bytesInFlightCount = 0;

        /**
         * @const {number}
         * @private
         */
        this._bytesInFlightLimit = options.ostreamHighWaterBytes;

        /**
         * @type {boolean}
         * @private
         */
        this._bytesInFlightPause = false;

        /**
         * @const {number}
         * @private
         */
        this._chunkRecycleLimit = options.ostreamChunkRecycleLimit;

        /**
         * @type {!Array<!Buffer>}
         * @private
         */
        this._chunkRecycleCache = [];

        /**
         * @type {boolean}
         * @private
         */
        this._nextTickNotActive = true;

        /**
         * @type {!Socket}
         * @private
         */
        this._socket = socket;

        /**
         * @type {!Encoder}
         */
        this.encoder = new Encoder(options, behavior,
            (minSize) => this._chunkAllocate(minSize),
            (useChunk, rawChunk) => this._chunkDispatch(useChunk, rawChunk)
        );

        socket
            .on('error', () => socket.destroyed ? this._onSocketClosed() : undefined)
            .on('close', () => this._onSocketClosed())
        ;

    }

    /**
     * @param {number} size
     */
    minDefaultChunkSize(size) {
        if (size > this._chunkDefaultSize) {
            this._chunkDefaultSize = size;
            this._chunkRecycleCache.length = 0;
        }
    }

    // noinspection JSUnusedGlobalSymbols, JSUnusedLocalSymbols
    /**
     * @param {!Method} method
     * @param {string} encoding
     * @param {function(Error=, Buffer=)} callback
     * @override
     * @final
     */
    _write(method, encoding, callback) {
        try {
            if (this.encoder.push(method) && this._nextTickNotActive) {
                this._nextTickNotActive = false;
                process.nextTick(() => this._onProcessNextTick());
            }
            if (this._bytesInFlightCount > this._bytesInFlightLimit) {
                this._bytesInFlightPause = true;
            }
            if (this._bytesInFlightPause) {
                this.once('continue', callback);
                return;
            }
            callback();
        } catch (e) {
            this.encoder.stop();
            callback(e);
        }
    }

    /**
     * @private
     */
    _onSocketClosed() {
        this.write = () => nop(false);
        this.encoder.stop();
        this._socket.write = () => nop(false);
        this._onProcessNextTick = nop;
    }

    /**
     * @private
     */
    _onProcessNextTick() {
        try {
            this._nextTickNotActive = true;
            this.encoder.flush();
        } catch (e) {
            this.encoder.stop();
            this.emit('error', e);
        }
    }

    /**
     * @param {number} minSize
     * @return {!Buffer}
     */
    _chunkAllocate(minSize) {
        if (minSize && minSize > this._chunkDefaultSize) {
            ++this.statChunkBigAllocCount;
            return Buffer.allocUnsafe(minSize);
        } else if (this._chunkRecycleCache.length === 0) {
            ++this.statChunkDefAllocCount;
            return Buffer.allocUnsafe(this._chunkDefaultSize);
        } else {
            ++this.statChunkRecycledCount;
            return this._chunkRecycleCache.pop();
        }
    }

    /**
     * @param {!Buffer} useChunk
     * @param {?Buffer} rawChunk
     */
    _chunkDispatch(useChunk, rawChunk) {
        this._bytesInFlightCount += useChunk.length;
        try {
            this._socket.write(useChunk, (error) => this._chunkReleased(error, useChunk, rawChunk));
        } catch(e) {
            this._onSocketClosed();
        }
    }

    /**
     * @param {!Error} error
     * @param {!Buffer} useChunk
     * @param {Buffer} rawChunk
     * @private
     */
    _chunkReleased(error, useChunk, rawChunk) {
        if (error) {
            this._onSocketClosed();
            return;
        }
        if (rawChunk && rawChunk.length === this._chunkDefaultSize && this._chunkRecycleCache.length < this._chunkRecycleLimit) {
            this._chunkRecycleCache.push(rawChunk);
        }
        this._bytesInFlightCount -= useChunk.length;
        if (this._bytesInFlightPause && this._bytesInFlightCount < this._bytesInFlightLimit) {
            this._bytesInFlightPause = false;
            this.emit('continue');
        }
    }

}

/**
 * @private
 */
class TcpConnection extends EventEmitter {

    /**
     * Closed before authenticated.
     * @event TcpConnection#abort
     * @param {boolean} hadError
     */

    /**
     * Authenticated successfully.
     * @event TcpConnection#valid
     */

    /**
     * Ready for use by protocol layer.
     * @event TcpConnection#ready
     */

    /**
     * Error occurred.
     * @event TcpConnection#error
     * @param {Error} error
     */

    /**
     * Inbound error requires to close, last chance to end with error frame instead of direct close.
     * @event TcpConnection#assert
     * @param {Error} error
     */

    /**
     * Ending without immediate close, last chance to set an individual close timer.
     * @event TcpConnection#final
     * @param {boolean} hadAssert
     * @param {number} closeTimeout
     */

    /**
     * Closed finally.
     * @event TcpConnection#close
     * @param {boolean} hadError
     */

    /**
     * @param {!ConnectOptions} options
     * @param {!Socket} socket
     * @param {!TcpReader} reader
     * @param {!TcpWriter} writer
     */
    constructor(options, socket, reader, writer) {
        super();

        /**
         * @type {ConnectOptions}
         */
        this.options = options;

        /**
         * @type {!Date}
         * @private
         */
        this._statConnectedSince = new Date();

        /**
         * @type {number}
         * @private
         */
        this._statInboundDrains = 0;

        /**
         * @type {number}
         * @private
         */
        this._statOutboundDrains = 0;

        /**
         * @type {number}
         * @private
         */
        this._statInboundHeartbeats = 0;

        /**
         * @type {number}
         * @private
         */
        this._statOutboundHeartbeats = 0;

        /**
         * @type {boolean}
         * @private
         */
        this._valid = false;

        /**
         * @type {boolean}
         * @private
         */
        this._ready = false;

        /**
         * @type {number}
         * @private
         */
        this._paused = 0;

        /**
         * @type {Error}
         * @private
         */
        this._assert = null;

        /**
         * @type {!Socket}
         */
        this._socket = socket;

        /**
         * @type {!TcpReader}
         */
        this.istream = reader;

        /**
         * @type {!TcpWriter}
         */
        this.ostream = writer;

        /* socket settings */

        if (options.tune.socketNoDelay) {
            socket.setNoDelay(true);
        }

        socket
            .on('error', (error) => this.emit('error', error))
            .on('end', () => socket.destroyed ? undefined : this.close())
            .on('close', (hadError) => this.emit(this._valid ? 'close' : 'abort', hadError))
        ;

        /* istream handler */

        this.istream
            .on('error', (error) => this.assert(error))
            .on('drain', () => ++this._statInboundDrains)
            .on('heartbeat', () => ++this._statInboundHeartbeats)
        ;

        /* ostream handler */

        this.ostream
            .on('error', (error) => this.close(error))
            .on('drain', () => ++this._statOutboundDrains)
        ;

        this._socket.pipe(this.istream);
    }

    /**
     * @param {boolean} local
     * @return {string}
     */
    host(local = false) {
        // noinspection JSUnresolvedVariable
        return local ? this._socket.localAddress : this._socket.remoteAddress;
    }

    /**
     * @param {boolean} local
     * @return {number}
     */
    port(local = false) {
        // noinspection JSUnresolvedVariable
        return local ? this._socket.localPort : this._socket.remotePort;
    }

    /**
     *
     */
    valid() {
        if (this._valid)
            return;
        this._valid = true;

        process.nextTick(() => {
            if (this._socket.destroyed)
                return;
            this.emit('valid');
        });
    }

    /**
     * @param {!number} timeout
     */
    ready(timeout) {
        if (this._ready)
            return;
        this._ready = true;

        if (timeout) {
            this._socket.on('timeout', () => this.heartbeat(timeout));
            this._socket.setTimeout(timeout);
        }

        this.istream.cork();
        process.nextTick(() => {
            if (this._socket.destroyed)
                return;
            this.emit('ready');
            this.istream.uncork();
        });
    }

    /**
     * @param {number} timeout
     */
    heartbeat(timeout) {
        try {
            this.ostream.encoder.writeHeartbeat();
            this.ostream.encoder.flush();
            ++this._statOutboundHeartbeats;
            this._socket.setTimeout(timeout);
        } catch (e) {
            this.heartbeat = nop;
        }
    }

    /**
     * @return {boolean}
     */
    paused() {
        return this._paused > 0;
    }

    /**
     *
     */
    pause() {
        this._paused += 1;
        this.istream.cork();
    }

    /**
     *
     */
    resume() {
        this._paused -= 1;
        this.istream.uncork();
    }

    /**
     * @param {Error} error
     */
    assert(error) {
        this._assert = error;
        if (this._valid && this._socket.end !== nop)
            this.emit('assert', error);
        if (this._socket.end !== nop)
            this.close(error);
    }

    /**
     * @param {Method=} method
     */
    end(method = null) {
        try {
            this._socket.removeAllListeners('timeout');
            const timeout = this.options.tune.socketEndCloseTimeout;
            if (timeout > 0) this._socket.setTimeout(timeout, () => this.close());

            this.emit('final', this._assert !== null, timeout);
            if (method) this.ostream.encoder.push(method);
            this._onBeforeEnd();

            this.ostream.encoder.flush();
            this.ostream.encoder.stop();
            this.ostream.end();
            this._socket.end();

            this._socket.end = nop;
            this.end = nop;
            this.pause = nop;
            this.resume = nop;
        } catch (e) {
            this._socket.end = nop;
            this.end = nop;
            this.pause = nop;
            this.resume = nop;
        }
    }

    /**
     * @abstract
     */
    _onBeforeEnd() {
    }

    /**
     * @param {Error=} error
     */
    close(error = null) {
        try {
            this.heartbeat = nop;
            this.ostream.encoder.stop();
            this.ostream.end();
            this._socket.destroy(error);

            this._socket.end = nop;
            this._socket.destroy = nop;
            this.end = nop;
            this.close = nop;
            this.pause = nop;
            this.resume = nop;
        } catch (e) {
            this._socket.end = nop;
            this._socket.destroy = nop;
            this.end = nop;
            this.close = nop;
            this.pause = nop;
            this.resume = nop;
        }
    }

    /**
     * @typedef {Object} TcpConnectionStatistics
     * @property {Date} connectedSince - The point in time when the connection was established
     * @property {number} inboundHeartbeats - The amount of heartbeats received from the broker since connected.
     * @property {number} outboundHeartbeats -  The amount of heartbeats sent to the broker since connected.
     * @property {number} inboundDrains - The amount of drain events for the inbound stream (after it was throttled).
     * @property {number} outboundDrains - The amount of drain events for the outbound stream (after it was throttled).
     * @property {number} inboundBytes - The amount of bytes received.
     * @property {number} outboundBytes - The amount of bytes sent.
     * @property {number} inboundMethods - The amount of methods received.
     * @property {number} outboundMethods - The amount of methods sent.
     * @property {number} inboundFrames - The amount of frames received (method, header and body frames).
     * @property {number} outboundFrames - The amount of frames sent (method, header and body frames).
     * @property {number} inboundChunks - The amount of chunks received.
     * @property {number} outboundChunks - The amount of chunks sent.
     * @property {number} outboundChunksRecycled - The outbound chunk recycle count
     * @property {number} outboundChunksDefAlloc - The amount of allocated chunks using default chunk size
     * @property {number} outboundChunksBigAlloc - The amount of allocated chunks above default chunk size
     */

    /**
     * @return {!TcpConnectionStatistics}
     */
    statistics() {
        return /** @type {TcpConnectionStatistics} */ {
            connectedSince         : this._statConnectedSince,
            inboundHeartbeats      : this._statInboundHeartbeats,
            outboundHeartbeats     : this._statOutboundHeartbeats,
            inboundDrains          : this._statInboundDrains,
            outboundDrains         : this._statOutboundDrains,
            inboundBytes           : this._socket.bytesRead,
            outboundBytes          : this._socket.bytesWritten,
            inboundMethods         : this.istream.decoder.statMethodCount,
            outboundMethods        : this.ostream.encoder.statMethodCount,
            inboundFrames          : this.istream.decoder.statFrameCount,
            outboundFrames         : this.ostream.encoder.statFrameCount,
            inboundChunks          : this.istream.decoder.statChunkCount,
            outboundChunks         : this.ostream.encoder.statChunkCount,
            outboundChunksRecycled : this.ostream.statChunkRecycledCount,
            outboundChunksDefAlloc : this.ostream.statChunkDefAllocCount,
            outboundChunksBigAlloc : this.ostream.statChunkBigAllocCount
        };
    }

}

/**
 * @param {!ClientOptions} options
 * @param {!Behavior} behavior
 * @param {!MethodFactory} factory
 * @param {!NotifyOfConnect} done
 * @param {!NotifyOfFailed} failed
 * @private
 */
function tlsConnect(options, behavior, factory, done, failed) {
    const socket = tls.connect(options.tls, () => {
        try {
            socket.removeListener('error', failed);
            done(new TcpConnection(options, socket, new TcpReader(options.tune, behavior, factory), new TcpWriter(options.tune, behavior, socket)));
        } catch(e) {
            failed(e);
        }
    });
    socket.once('error', failed);
}

/**
 * @param {!ClientOptions} options
 * @param {!Behavior} behavior
 * @param {!MethodFactory} factory
 * @param {!NotifyOfConnect} done
 * @param {!NotifyOfFailed} failed
 * @private
 */
function netConnect(options, behavior, factory, done, failed) {
    const socket = net.connect(options.net, () => {
        try {
            socket.removeListener('error', failed);
            done(new TcpConnection(options, socket, new TcpReader(options.tune, behavior, factory), new TcpWriter(options.tune, behavior, socket)));
        } catch(e) {
            failed(e);
        }
    });
    socket.once('error', failed);
}

/**
 * @param {*=} result
 * @return {*}
 * @private
 */
function nop(result) { return result; }

module.exports = {
    TcpReader : TcpReader,
    TcpWriter : TcpWriter,
    TcpConnection : TcpConnection,
    tlsConnect : tlsConnect,
    netConnect : netConnect
};

