'use strict';

const EventEmitter = require('events');
const fs = require('fs');
const url = require('url');
const { EC, ErrMsg, Raise } = require('./errors');
const { mergeValues } = require('./tools/options');
const { Method } = require('./serialize/types');
const { Behavior } = require('./serialize/behavior');
const { Model } = require('./methods/model');
const { tlsConnect, netConnect } = require('./transport/tcp');
const { Controller } = require('./model/controller');
const { Credentials } = require('./sasl/credentials');
const { Channel } = require('./model/channel');
const { IStream, OStream } = require('./model/streams');

const constants = require('./serialize/constants');
const START = constants.METHOD.CONNECTION.START;
const SECURE = constants.METHOD.CONNECTION.SECURE;
const TUNE = constants.METHOD.CONNECTION.TUNE;
const CLOSE = constants.METHOD.CONNECTION.CLOSE;
const PRODUCT = constants.BEHAVIOR.PEER.PRODUCT;
const VERSION = constants.BEHAVIOR.PEER.VERSION;
const PLATFORM = constants.BEHAVIOR.PEER.PLATFORM;
const CAPABILITIES = constants.BEHAVIOR.PEER.CAPABILITIES;
const HEADSIZE = constants.FRAME.SIZE.HEADER;
const ENDSIZE = constants.FRAME.SIZE.END;

/**
 * @typedef  {Object} ClientOptions
 * @property {Object} net - The options for the net.connect(), see {@link https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener options}.
 * @property {Object} tls - The options for the tls.connect(), used in favour of net {@link https://nodejs.org/api/tls.html#tls_tls_connect_options_callback options}.
 * @property {string|Array<string>} uri - URI encoded connection data, defined parts overwrite defaults, array provides alternatives, see {@link https://www.rabbitmq.com/uri-spec.html specification}
 * @property {SaslClientConfig} sasl - SASL settings
 * @property {ProtocolSettings} amqp - Protocol specific settings
 * @property {StreamParameters} tune - Fine tuning
 * @property {UnifiedStreamDeclarationToConsume} istreams - Required unified consumer streams.
 * @property {UnifiedStreamDeclarationToProduce} ostreams - Required unified producer streams.
 */

/**
 * @const {ClientOptions}
 */
const CLIENT_DEFAULT_OPTIONS     = Object.freeze({
    tls                          : Object.freeze({
        host                     : '127.0.0.1',
        port                     : 5671
    }),
    net                          : Object.freeze({
        host                     : '127.0.0.1',
        port                     : 5672
    }),
    sasl                         : Object.freeze({
        mechanism                : 'PLAIN',
        user                     : 'guest',
        password                 : 'guest'
    }),
    amqp                         : Object.freeze({
        vhost                    : '/',
        locale                   : 'en_US',
        heartbeatInterval        : 60,
        maxBodyFrameSize         : 4088,
    }),
    tune                         : Object.freeze({
        istreamHighWaterFrames   : 16,
        istreamHighWaterBytes    : 16384,
        ostreamHighWaterFrames   : 16,
        ostreamHighWaterBytes    : 16384,
        ostreamChunkRecycleLimit : 16,
        ostreamChunkDefaultSize  : 4096,
        ostreamPayloadCopyLimit  : 1024,
        socketNoDelay            : false,
        socketEndCloseTimeout    : 300
    }),
    istreams                     : Object.freeze({
    }),
    ostreams                     : Object.freeze({
    })
});

/**
 * @const {ClientOptions}
 */
const CLIENT_MINIMUM_OPTIONS     = Object.freeze({
    amqp                         : Object.freeze({
        maxBodyFrameSize         : 1024,
    }),
    tune                         : Object.freeze({
        istreamHighWaterFrames   : 4,
        istreamHighWaterBytes    : 4096,
        ostreamHighWaterFrames   : 4,
        ostreamHighWaterBytes    : 4096,
        ostreamChunkRecycleLimit : 0,
        ostreamChunkDefaultSize  : 512,
        ostreamPayloadCopyLimit  : 128,
        socketEndCloseTimeout    : 0
    })
});

/**
 * @enum {number}
 * @private
 */
const CLIENT_STATE = Object.freeze({
    CONNECTING                   : 0x01,
    CONNECTED                    : 0x02,
    DISCONNECTING                : 0x03,
    DISCONNECTED                 : 0x04
});

/**
 * A client instance represents a single connection to the broker.
 */
class Client extends EventEmitter {

    /**
     * The client is now connected.
     * @event Client#connected
     * @param {number} destination - Used destination, can be greater than 0 if multiple URIs are defined.
     * @param {PeerData} peerInfo - Peer info
     */

    /**
     * The client is now reconnecting using an alternative destination.
     * @event Client#reconnecting
     * @param {number} destination - Used destination, can be greater than 0 if multiple URIs are defined.
     */

    /**
     * The client is now disconnected. No automatic reconnect will follow. Wait a short time with (re-) connect.
     * @event Client#disconnected
     * @param {boolean} hadError - An error occurred and forced the connection to be closed.
     * @param {boolean} byServer - The server has closed the connection (unexpectedly).
     * @param {!TcpConnectionStatistics} statistics - Statistics for the already closed connection.
     */

    /**
     * The client received a heartbeat from the broker. It means also the client is currently idle.
     * @event Client#heartbeat
     * @param {number} heartbeatInterval - The idle duration in seconds after which a heartbeat will be sent.
     */

    /**
     * The client is able to accept further data, after the application was asked to pause publish calls temporarily.
     * @event Client#drain
     */

    /**
     * An error occurred.
     * @event Client#error
     * @param {!Error} error - The error object that originates from internally processing or from callbacks.
     */

    /**
     * Create a new client
     * @param {(ClientOptions|Object)=} options - The options to use for a client
     * @throws {!Error} - If options are invalid
     */
    constructor(options) {

        super();

        /**
         * @const {!Array<!ClientOptions>}
         * @private
         */
        this._options = setupOptions(options);

        /**
         * @type {number}
         * @private
         */
        this._optUsed = 0;

        /**
         * @type {ClientOptions}
         * @private
         */
        this._optBase = this._options[0];

        /**
         * @type {!number}
         * @private
         */
        this._state = CLIENT_STATE.DISCONNECTED;

        /**
         * @type {!Model}
         * @private
         */
        this._model = new Model();

        /**
         * @type {!Behavior}
         */
        this._behavior = new Behavior(this._optBase.amqp);

        /**
         * @type {TcpConnection}
         * @private
         */
        this._connection = null;

        /**
         * @type {!Controller}
         * @private
         */
        this._controller = new Controller(this._behavior, 0);

        /**
         * @const {!Map<number, !{controller: Controller, channel: Channel}>}
         * @private
         */
        this._channels = new Map([[Number(0), {controller: this._controller, channel: null}]]);

        /**
         * @type {Map<string, IStream>}
         * @private
         */
        this._istreams = new Map();

        /**
         * @type {Map<string, OStream>}
         * @private
         */
        this._ostreams = new Map();

        /* setup consumer streams (istreams) */
        Object.getOwnPropertyNames(this._optBase.istreams).forEach((id) => {
            const settings = this._optBase.istreams[id];
            if (settings === null || typeof settings !== 'object' || settings.constructor !== Object) {
                throw ErrMsg(EC.APP_ARGS_INVALID_ISTREAM_OPTIONS, id);
            }
            const channel = this.channel(settings.channel);
            const controller = this._channels.get(settings.channel).controller;
            this._istreams.set(id, new IStream(id, channel, controller, settings));
        });

        /* setup producer streams (ostreams) */
        Object.getOwnPropertyNames(this._optBase.ostreams).forEach((id) => {
            const settings = this._optBase.ostreams[id];
            if (settings === null || typeof settings !== 'object' || settings.constructor !== Object) {
                throw ErrMsg(EC.APP_ARGS_INVALID_OSTREAM_OPTIONS, id);
            }
            const channel = this.channel(settings.channel);
            const controller = this._channels.get(settings.channel).controller;
            this._ostreams.set(id, new OStream(id, channel, controller, settings));
        });

    }

    /**
     * @param {NotifyOfDone=} done
     * @param {NotifyOfFailed=} failed
     */
    connect(done = null, failed = null) {

        /* check status */

        switch (this._state) {
            case CLIENT_STATE.CONNECTING: {
                Raise(ErrMsg(EC.CLIENT_STATE_ERROR, 'connect', 'connecting'), failed);
                return;
            }
            case CLIENT_STATE.CONNECTED: {
                Raise(ErrMsg(EC.CLIENT_STATE_ERROR, 'connect', 'connected'), failed);
                return;
            }
            case CLIENT_STATE.DISCONNECTING: {
                Raise(ErrMsg(EC.CLIENT_STATE_ERROR, 'connect', 'disconnecting'), failed);
                return;
            }
        }
        this._state = CLIENT_STATE.CONNECTING;

        /* create socket and connect */

        const options = this._options[this._optUsed];

        const init = (connection) => this._onConnectionOpened(connection, options, done, failed);
        const fail = (error) => this._onConnectionFailed(error, true, done, failed);

        if (options.tls) {
            tlsConnect(options, this._controller.behavior, /**@type{MethodFactory}}*/(this._model), init, fail);
        } else if (options.net) {
            netConnect(options, this._controller.behavior, /**@type{MethodFactory}}*/(this._model), init, fail);
        } else {
            fail(ErrMsg(EC.CLIENT_MISS_DEST));
        }
    }

    /**
     * @param {!TcpConnection} connection
     * @param {!ClientOptions} options
     * @param {?NotifyOfDone} done
     * @param {?NotifyOfFailed} failed
     * @private
     */
    _onConnectionOpened(connection, options, done, failed) {
        // noinspection JSUnresolvedFunction
        connection
            .once('valid', () => this._onConnectionValid(connection, done))
            .on('assert', (error) => this._onConnectionAssert(error))
            .on('error', (error) => this._onConnectionError(error))
            .once('abort', (hadError) => this._onConnectionFailed(null, hadError, done, failed))
        ;
        connection.istream
            .on('data', (method) => this._channels.get(method.channelID).controller.dispatch(method))
            .on('heartbeat', () => this.emit('heartbeat', this._controller.behavior.heartbeatInterval))
        ;
        connection.ostream
            .on('drain', () => this.emit('drain'))
        ;
        this._connection = connection;
        this._controller.start(connection.ostream);
        this._awaitMethodStart(connection);
        connection.ostream.encoder.writeProtocol();
        connection.ostream.encoder.flush();
    }

    /**
     * @param {!TcpConnection} connection
     * @param {?NotifyOfDone} done
     * @private
     */
    _onConnectionValid(connection, done) {
        // noinspection JSUnresolvedFunction
        connection
            .removeAllListeners('abort')   // will release the connect failed callback
            .once('ready', () => this._onConnectionReady(connection, done))
            .once('close', (hadError) => this._onConnectionClosed(connection, hadError))
        ;

        if (this._state !== CLIENT_STATE.CONNECTING) {
            connection.close();
        }
    }

    /**
     * @param {!TcpConnection} connection
     * @param {?NotifyOfDone} done
     * @private
     */
    _onConnectionReady(connection, done) {
        for (const [id, item] of this._channels) {
            if (id !== 0) item.controller.start(connection.ostream);
        }
        this._state = CLIENT_STATE.CONNECTED;
        if (typeof done === 'function') done();
        this.emit('connected', this._optUsed, Object.assign({}, this._behavior.brokerInfo));
    }

    /**
     * @param {!Error} error
     * @private
     */
    _onConnectionAssert(error) {
        this._connection.close(error);
    }

    /**
     * @param {!Error} error
     * @private
     */
    _onConnectionError(error) {
        if (this._state === CLIENT_STATE.DISCONNECTING) {
            switch(error.code) {
                case 'ECONNRESET':
                    return;
                case 'ECONNABORTED':
                    return;
            }
        }
        this.emit('error', error);
    }

    /**
     * @param {!TcpConnection} connection
     * @param {boolean} hadError
     * @private
     */
    _onConnectionClosed(connection, hadError) {
        const byServer = this._state === CLIENT_STATE.CONNECTED;
        const statistics = connection.statistics();
        this._state = CLIENT_STATE.DISCONNECTED;
        this._optUsed = 0;
        this._connection = null;
        this.emit('disconnected', hadError, byServer, statistics);
    }

    /**
     * @param {Error} error
     * @param {boolean} hadError
     * @param {?NotifyOfDone} done
     * @param {?NotifyOfFailed} failed
     * @private
     */
    _onConnectionFailed(error, hadError, done, failed) {
        this._state = CLIENT_STATE.DISCONNECTED;
        if (error) {
            switch(error.code) {
                case 'ECONNREFUSED':
                    Raise(ErrMsg(EC.CLIENT_CONNECT_REFUSED), failed, this);
                    break;
                case 'ETIMEDOUT':
                    Raise(ErrMsg(EC.CLIENT_CONNECT_TIMEOUT), failed, this);
                    break;
                default:
                    Raise(error, failed, this);
            }
        } else if (!hadError) {
            Raise(ErrMsg(EC.CLIENT_CONNECT_FAILURE), failed, this);
        }
        if (++this._optUsed < this._options.length) {
            this.emit('reconnecting', this._optUsed);
            process.nextTick(() => this.connect(done, failed));
        } else {
            this._optUsed = 0;
            this.emit('disconnected', hadError, false);
        }
    }

    /**
     * @param {!TcpConnection} connection
     * @private
     */
    _awaitMethodStart(connection) {
        this._controller.receive(START, null, (method) => {
            const start = /** {ConnectionStart} */(method);
            this._controller.cancel(START, null);
            this._awaitMethodSecure(connection);
            this._awaitMethodTune(connection);
            this._awaitMethodClose(connection);

            this._controller.behavior.updateBroker(
                start.serverProperties.get(PRODUCT).toData(),
                start.serverProperties.get(VERSION).toData(),
                start.serverProperties.get(PLATFORM).toData(),
                start.serverProperties.get(CAPABILITIES).toData()
            );
            const strType = start.serverProperties.get(PRODUCT).getType();
            const credentials = new Credentials(this._options[this._optUsed]);
            const startOk = new Model.Connection.StartOk();
            startOk.mechanism = credentials.selectMechanism(start.mechanisms);
            startOk.response = credentials.provideResponse(startOk.mechanism);
            startOk.locale = this._controller.behavior.selectLocale(start.locales);
            startOk.clientProperties.get(PRODUCT).setValue(this._controller.behavior.clientInfo.product, strType);
            startOk.clientProperties.get(VERSION).setValue(this._controller.behavior.clientInfo.version, strType);
            startOk.clientProperties.get(PLATFORM).setValue(this._controller.behavior.clientInfo.platform, strType);
            this._controller.send(startOk);
        });
    }

    /**
     * @param {!TcpConnection} connection
     * @private
     */
    _awaitMethodSecure(connection) {
        this._controller.receive(SECURE, null, (method) => {
            const secure = /** {ConnectionSecure} */(method);
            const credentials = new Credentials(this._options[this._optUsed]);
            const secureOk = new Model.Connection.SecureOk();
            secureOk.response = credentials.answerChallenge(secure.challenge);
            this._controller.send(secureOk);
        });
    }

    /**
     * @param {!TcpConnection} connection
     * @private
     */
    _awaitMethodTune(connection) {
        this._controller.receive(TUNE, null, (method) => {
            const tune = /** {ConnectionTune} */(method);
            this._controller.cancel(SECURE, null);
            this._controller.cancel(TUNE, null);

            connection.valid();

            this._controller.behavior.maxChannel = tune.channelMax;
            if (tune.frameMax) {
                this._controller.behavior.maxFrameSize = tune.frameMax;
                connection.ostream.minDefaultChunkSize(tune.frameMax + HEADSIZE + ENDSIZE);
            }
            if (this._controller.behavior.heartbeatInterval < 0) {
                this._controller.behavior.heartbeatInterval = tune.heartbeat;
            }

            const tuneOk = new Model.Connection.TuneOk();
            tuneOk.channelMax = this._controller.behavior.maxChannel;
            tuneOk.frameMax = this._controller.behavior.maxFrameSize;
            tuneOk.heartbeat = this._controller.behavior.heartbeatInterval;
            this._controller.send(tuneOk);

            const open = new Model.Connection.Open();
            open.virtualHost = this._options[this._optUsed].amqp.vhost;
            this._controller.request(open, (error, response) => {
                if (response) {
                    connection.ready(this._controller.behavior.connectionTimeout());
                } else if (error) {
                    connection.close(error);
                }
            });
        });
    }

    /**
     * @param {!TcpConnection} connection
     * @private
     */
    _awaitMethodClose(connection) {
        this._controller.receive(CLOSE, null, (method) => {
            const close = /** {ConnectionClose} */(method);
            if (close.failed) {
                this.emit('error', ErrMsg(EC.CONNECTION_ERROR_AT_METHOD, Method.describeID(close.failed), close.replyCode, close.replyText));
            } else if (close.replyCode) {
                this.emit('error', ErrMsg(EC.CONNECTION_ERROR, close.replyCode, close.replyText));
            }
            connection.end(new Model.Connection.CloseOk());
        });
    }

    /**
     * Client shall disconnect from server
     * @param {NotifyOfDone=} done
     * @param {NotifyOfFailed=} failed
     */
    disconnect(done, failed) {
        switch (this._state) {
            case CLIENT_STATE.CONNECTING: {
                this._state = CLIENT_STATE.DISCONNECTING;
                if (typeof done === 'function') this.once('disconnected', done);
                if (this._connection === null) return;
                this._connection.close();      // close connection immediately
                break;
            }
            case CLIENT_STATE.CONNECTED: {
                this._state = CLIENT_STATE.DISCONNECTING;
                if (typeof done === 'function') this.once('disconnected', done);
                this._channels.forEach((item, id) => {
                    if (id !== 0) item.controller.close();
                });
                this._controller.request(new Model.Connection.Close(), (error /*, response */) => {
                    if (error) {
                        Raise(error, failed);
                    } else {
                        this._connection.close();
                    }
                });
                break;
            }
            case CLIENT_STATE.DISCONNECTING: {
                Raise(ErrMsg(EC.CLIENT_STATE_ERROR, 'disconnect', 'disconnecting'), failed);
                break;
            }
            case CLIENT_STATE.DISCONNECTED: {
                Raise(ErrMsg(EC.CLIENT_STATE_ERROR, 'disconnect', 'disconnected'), failed);
                break;
            }
        }
    }

    // noinspection JSUnusedGlobalSymbols
    /**
     * Returns current connection statistics while being connected and null otherwise.
     * The event 'disconnected' will also provide statistics, a very last time, after the connection was already destroyed.
     * @return {?TcpConnectionStatistics}
     */
    statistics() {
        return this._connection ? this._connection.statistics() : null;
    }

    /**
     * Indicates whether or not the client was called to pause receiving any data
     * @return {boolean}
     */
    pausing() {
        return this._state === CLIENT_STATE.CONNECTED ? this._connection.paused() : false;
    }

    /**
     * <p>The client shall pause receiving any data, as the broker is sending faster than the application can consume.</p>
     * <p>Before using this method consider changing one single channels flow only.</p>
     * <p>As soon as possible call the client to resume.</p>
     * <p>The whole connection is paused. Hence, it affects for example also confirms as well as connection or channel exceptions.</p>
     */
    pause() {
        if (this._state === CLIENT_STATE.CONNECTED) this._connection.pause();
    }

    /**
     * The client shall continue to receive data, after pause was called previously.
     */
    resume() {
        if (this._state === CLIENT_STATE.CONNECTED) this._connection.resume();
    }

    /**
     * @param {!number} id
     * @return {Channel}
     */
    channel(id) {
        const ch = Number(id);
        let item = this._channels.get(ch);
        if (!item || !item.channel) {
            if (!Number.isInteger(ch) || ch < 0x0001 || ch > 0xFFFF) {
                throw ErrMsg(EC.APP_ARGS_INVALID_CHANNEL_ID, ch);
            }
            const controller = new Controller(this._controller.behavior, ch);
            if (this._state === CLIENT_STATE.CONNECTED) {
                const connection = this._connection;
                controller.start(connection.ostream);
            }
            item = {
                /** @const {!Controller} */
                controller: controller,
                /** @const {!Channel} */
                channel: new Channel(this, controller)
            };
            this._channels.set(ch, item);
        }
        return item.channel;
    }

    /**
     * Provide a unified consumer stream instance
     * @param {!string} id - The id that was declared as part of the client options
     * @returns {!IStream} A readable stream for unified stream messages
     */
    istream(id) {
        const stream = this._istreams.get(id);
        if (stream) {
            return stream;
        } else {
            throw ErrMsg(EC.APP_ARGS_INVALID_ISTREAM_ID, id);
        }
    }

    /**
     * Provide a unified producer stream instance
     * @param {!string} id - The id that was declared as part of the client options
     * @returns {!OStream} A writable stream for unified stream messages
     */
    ostream(id) {
        const stream = this._ostreams.get(id);
        if (stream) {
            return stream;
        } else {
            throw ErrMsg(EC.APP_ARGS_INVALID_OSTREAM_ID, id);
        }
    }

}

/**
 * @typedef {Object} UriData
 * @property {string} protocol
 * @property {string} hostname
 * @property {number} port
 * @property {string} pathname
 * @property {string} auth
 * @property {Object} query
 * @property {string} query.cacertfile
 * @property {string} query.certfile
 * @property {string} query.keyfile
 * @private
 */

/**
 * @param {!ClientOptions} target
 * @param {!string} uri
 * @return {!ClientOptions}
 * @private
 */
function mergeCfgURI(target, uri) {
    /** @const {UriData} */
    const data = url.parse(uri, true, false);

    switch(data.protocol) {
        case 'amqp:':
        {
            delete target.tls;

            if (!target.net) {
                target.net = Object.assign({}, CLIENT_DEFAULT_OPTIONS.net);
            }
            if (data.hostname) {
                target.net.host = data.hostname;
            }
            if (data.port) {
                target.net.port = parseInt(data.port);
            }

            break;
        }
        case 'amqps:':
        {
            delete target.net;

            if (!target.tls) {
                target.tls = Object.assign({}, CLIENT_DEFAULT_OPTIONS.tls);
            }
            if (data.hostname) {
                target.tls.host = data.hostname;
            }
            if (data.port) {
                target.tls.port = parseInt(data.port);
            }

            const ca = data.query.cacertfile;
            if (ca) {
                if (Array.isArray(ca)) {
                    target.tls.ca = [];
                    for (const file of ca) {
                        target.tls.ca.push(fs.readFileSync(file));
                    }
                } else {
                    target.tls.ca = fs.readFileSync(ca);
                }
            }

            const cert = data.query.certfile;
            if (cert) {
                if (Array.isArray(cert)) {
                    target.tls.cert = [];
                    for (const file of cert) {
                        target.tls.cert.push(fs.readFileSync(file));
                    }
                } else {
                    target.tls.cert = fs.readFileSync(cert);
                }
            }

            const key = data.query.keyfile;
            if (key) {
                if (Array.isArray(key)) {
                    target.tls.key = [];
                    for (const file of key) {
                        target.tls.key.push(fs.readFileSync(file));
                    }
                } else {
                    target.tls.key = fs.readFileSync(key);
                }
            }

            break;
        }
        case null:
            break;
        default: {
            throw ErrMsg(EC.APP_ARGS_INVALID_URI_SCHEMA, data.protocol);
        }
    }

    if (!target.sasl) {
        target.sasl = {};
    }
    if (typeof data.auth === 'string') {
        const spos = data.auth.indexOf(':');
        if (spos === -1) {
            target.sasl.user = data.auth;
            target.sasl.password = '';
        } else {
            target.sasl.user = data.auth.slice(0, spos);
            target.sasl.password = data.auth.slice(spos + 1);
        }
    }

    if (!target.amqp) {
        target.amqp = {};
    }
    if (typeof data.pathname === 'string' && data.pathname.length > 1) {
        target.amqp.vhost = decodeURIComponent(data.pathname.slice(1));
    }
    if (data.query.heartbeat) {
        target.amqp.heartbeatInterval = typeof data.query.heartbeat === 'string' ? parseInt(data.query.heartbeat) : parseInt(data.query.heartbeat[0]);
    }

    return target;
}

/**
 * @param {(ClientOptions|Object)=} options
 * @return {!Array<ClientOptions>}
 * @private
 */
function setupOptions(options) {
    const cfg = {};

    if (options) {
        if (typeof options !== 'object') {
            throw ErrMsg(EC.APP_ARGS_INVALID_TYPE_FOR_CLIENT_OPTIONS, 'options', 'object');
        }
        if (options.constructor !== Object) {
            throw ErrMsg(EC.APP_ARGS_INVALID_TYPE_FOR_CLIENT_OPTIONS, 'options', 'object');
        }
        mergeValues(cfg, options, [], false);
        delete cfg.uri;
        mergeValues(cfg, CLIENT_DEFAULT_OPTIONS, ['tls', 'net'], false);

        if (!cfg.tls && !cfg.net) cfg.net = mergeValues({}, CLIENT_DEFAULT_OPTIONS.net, [], false);
    } else {
        mergeValues(cfg, CLIENT_DEFAULT_OPTIONS, ['tls'], false); // net
        return [cfg];
    }

    if (typeof options.uri === 'string') {
        mergeCfgURI(cfg, options.uri);
        mergeValues(cfg, CLIENT_MINIMUM_OPTIONS, [], true);
        if (!cfg.tls && !cfg.net) cfg.net = CLIENT_DEFAULT_OPTIONS.net;
        return [cfg];
    }

    if (Array.isArray(options.uri)) {
        const result = [];
        for (const uri of options.uri) {
            if (typeof uri !== 'string')
                throw ErrMsg(EC.APP_ARGS_INVALID_TYPE_FOR_CLIENT_OPTIONS, 'uri[i]', 'string');
            /** @type{ClientOptions}*/
            const data = mergeValues({}, cfg, [], false);
            mergeCfgURI(data, uri);
            mergeValues(data, CLIENT_MINIMUM_OPTIONS, [], true);
            if (!data.tls && !data.net) data.net = CLIENT_DEFAULT_OPTIONS.net;
            result.push(data);
        }
        if (result.length) {
            return result;
        } else {
            delete options.uri;
        }
    }

    if (options.uri === undefined) {
        mergeValues(cfg, CLIENT_MINIMUM_OPTIONS, [], true);
        if (!cfg.tls && !cfg.net) cfg.net = CLIENT_DEFAULT_OPTIONS.net;
        return [cfg];
    }

    throw ErrMsg(EC.APP_ARGS_INVALID_TYPE_FOR_CLIENT_OPTIONS, 'uri', 'string|array|undefined');
}

module.exports = {
    Client : Client,
    mergeCfgURI : mergeCfgURI,
    setupOptions : setupOptions
};

